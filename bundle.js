(()=>{"use strict";var n={84:(n,t,r)=>{var _="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var a=Math.PI/180;function e(){var n=new _(16);return _!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function o(n,t){var r=t[0],_=t[1],a=t[2],e=t[3],o=t[4],i=t[5],p=t[6],m=t[7],v=t[8],l=t[9],s=t[10],f=t[11],c=t[12],h=t[13],d=t[14],u=t[15],g=r*i-_*o,b=r*p-a*o,y=r*m-e*o,x=_*p-a*i,C=_*m-e*i,S=a*m-e*p,P=v*h-l*c,z=v*d-s*c,w=v*u-f*c,E=l*d-s*h,L=l*u-f*h,I=s*u-f*d,k=g*I-b*L+y*E+x*w-C*z+S*P;return k?(k=1/k,n[0]=(i*I-p*L+m*E)*k,n[1]=(a*L-_*I-e*E)*k,n[2]=(h*S-d*C+u*x)*k,n[3]=(s*C-l*S-f*x)*k,n[4]=(p*w-o*I-m*z)*k,n[5]=(r*I-a*w+e*z)*k,n[6]=(d*y-c*S-u*b)*k,n[7]=(v*S-s*y+f*b)*k,n[8]=(o*L-i*w+m*P)*k,n[9]=(_*w-r*L-e*P)*k,n[10]=(c*C-h*y+u*g)*k,n[11]=(l*y-v*C-f*g)*k,n[12]=(i*z-o*E-p*P)*k,n[13]=(r*E-_*z+a*P)*k,n[14]=(h*b-c*x-d*g)*k,n[15]=(v*x-l*b+s*g)*k,n):null}Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)});var i=function(n,t,r){var _=t[0],a=t[1],e=t[2],o=t[3],i=t[4],p=t[5],m=t[6],v=t[7],l=t[8],s=t[9],f=t[10],c=t[11],h=t[12],d=t[13],u=t[14],g=t[15],b=r[0],y=r[1],x=r[2],C=r[3];return n[0]=b*_+y*i+x*l+C*h,n[1]=b*a+y*p+x*s+C*d,n[2]=b*e+y*m+x*f+C*u,n[3]=b*o+y*v+x*c+C*g,b=r[4],y=r[5],x=r[6],C=r[7],n[4]=b*_+y*i+x*l+C*h,n[5]=b*a+y*p+x*s+C*d,n[6]=b*e+y*m+x*f+C*u,n[7]=b*o+y*v+x*c+C*g,b=r[8],y=r[9],x=r[10],C=r[11],n[8]=b*_+y*i+x*l+C*h,n[9]=b*a+y*p+x*s+C*d,n[10]=b*e+y*m+x*f+C*u,n[11]=b*o+y*v+x*c+C*g,b=r[12],y=r[13],x=r[14],C=r[15],n[12]=b*_+y*i+x*l+C*h,n[13]=b*a+y*p+x*s+C*d,n[14]=b*e+y*m+x*f+C*u,n[15]=b*o+y*v+x*c+C*g,n};function p(n,t,r){var _=n.createShader(t);if(n.shaderSource(_,r),n.compileShader(_),n.getShaderParameter(_,n.COMPILE_STATUS))return _;console.log(n.getShaderInfoLog(_)),n.deleteShader(_)}function m(n){var t=n.createTexture();return n.bindTexture(n.TEXTURE_2D,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),t}function v(n,t,r){n.canvas.width=t,n.canvas.height=r,n.viewport(0,0,n.canvas.width,n.canvas.height)}var l=r(675),s=r(574);const f=JSON.parse('{"nS":{"x":0,"y":0,"z":16,"fx":0,"tW":-0.05,"Bp":0.7,"On":0.1,"NC":50},"H":[{"x":0,"y":3.999999,"z":0,"r":1,"g":1,"b":1,"sizeX":1,"sizeY":1,"brightness":100,"spotSize":0.001,"spotIntensity":1.5,"rotate":false,"enabled":true},{"x":-3.3,"y":2.5,"z":0,"r":1,"g":1,"b":1,"sizeX":0.3,"sizeY":0.3,"brightness":100,"spotSize":0.9,"spotIntensity":0,"rotate":true,"enabled":false}],"vi":[{"x":1.25,"y":-1.5,"z":-1.5,"r":0.9,"g":0.5,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":2.5,"y":-3.2,"z":-1.5,"r":0,"g":0,"b":0,"rr":1,"rg":1,"rb":1,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":0,"y":-3.2,"z":-1.5,"r":0.9,"g":0.1,"b":0.1,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.35},{"x":-2.5,"y":-3.2,"z":-1.5,"r":0.1,"g":0.9,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.5}],"Rm":[{"x":0,"y":1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"floor"},{"x":0,"y":-1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"ceiling"},{"x":-1,"y":0,"z":0,"r":1,"g":0.1,"b":0.1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"right wall"},{"x":1,"y":0,"z":0,"r":0.1,"g":1,"b":0.1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"left wall"},{"x":0,"y":0,"z":1,"r":0.9,"g":0.9,"b":0.5,"specular":0,"roughness":0.25,"offset":-4,"enabled":true,"desc":"back wall"},{"x":0,"y":0,"z":-1,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":false,"desc":"front wall"}]}');var c=document.getElementById("fps"),h=!0,d=!0,u=!0,g=!1,b=!1,y=!1,x=!1,C=!1,S=0,P=0,z=0,w=0,E=document.querySelector("#canvas"),L=E.getContext("webgl2",{powerPreference:"high-performance",antialias:!1,alpha:!0,stencil:!1,depth:!1,desynchronized:!1,preserveDrawingBuffer:!1}),I=function(n,t,r){console.log("COMPILING SHADERS");var _=p(n,n.VERTEX_SHADER,t),a=p(n,n.FRAGMENT_SHADER,r);console.log("CREATING PROGRAM"),v(n,1280,720),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT);var e=function(n,t,r){var _=n.createProgram();if(n.attachShader(_,t),n.attachShader(_,r),n.linkProgram(_),n.getProgramParameter(_,n.LINK_STATUS))return _;console.log(n.getProgramInfoLog(_)),n.deleteProgram(_)}(n,_,a);return n.useProgram(e),console.log("FINISH"),e}(L,l,s),k=L.getUniformLocation(I,"enableTAA"),R=L.getUniformLocation(I,"randomseed"),T=(L.getUniformLocation(I,"sphereCenters[0]"),L.getUniformLocation(I,"u_texture")),A=m(L);L.texImage2D(L.TEXTURE_2D,0,L.RGBA,L.canvas.width,L.canvas.height,0,L.RGBA,L.UNSIGNED_BYTE,null);var N=L.createFramebuffer();L.bindFramebuffer(L.DRAW_FRAMEBUFFER,N),L.framebufferTexture2D(L.DRAW_FRAMEBUFFER,L.COLOR_ATTACHMENT0,L.TEXTURE_2D,A,0);var B=m(L);L.texImage2D(L.TEXTURE_2D,0,L.RGBA,L.canvas.width,L.canvas.height,0,L.RGBA,L.UNSIGNED_BYTE,null);var M=L.createFramebuffer();L.bindFramebuffer(L.DRAW_FRAMEBUFFER,M),L.framebufferTexture2D(L.DRAW_FRAMEBUFFER,L.COLOR_ATTACHMENT0,L.TEXTURE_2D,B,0);var U=!0,F=!0,D=50,q=1,G=!0,O=9,V=!0,X=!1,H=1.5,W=0,Y=f.nS.On,j=f.nS.NC,K=f.nS.Bp,Z=f.nS.x,J=f.nS.y,Q=f.nS.z,$=f.nS.fx,nn=f.nS.tW,tn=e(),rn=e(),_n=e(),an=e(),en=e(),on=e(),pn=e();function mn(n){var t,r,_,a;b&&(Z+=4*n*Math.cos(nn)*Math.cos($+Math.PI/2),J+=4*n*Math.sin(nn),Q-=4*n*Math.cos(nn)*Math.sin($+Math.PI/2)),x&&(Z-=4*n*Math.cos(nn)*Math.cos($+Math.PI/2),J-=4*n*Math.sin(nn),Q+=4*n*Math.cos(nn)*Math.sin($+Math.PI/2)),y&&(Z+=4*n*Math.cos($+Math.PI),Q-=4*n*Math.sin($+Math.PI)),C&&(Z+=4*n*Math.cos($),Q-=4*n*Math.sin($)),function(n,t,r,_,a){var e,o=1/Math.tan(t/2);n[0]=o/r,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=o,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,null!=a&&a!==1/0?(e=1/(_-a),n[10]=(a+_)*e,n[14]=2*a*_*e):(n[10]=-1,n[14]=-2*_)}(tn,K,L.canvas.width/L.canvas.height,Y,j),t=rn,r=$,_=Math.sin(r),a=Math.cos(r),t[0]=a,t[1]=0,t[2]=-_,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=_,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,function(n,t){var r=Math.sin(t),_=Math.cos(t);n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=_,n[6]=r,n[7]=0,n[8]=0,n[9]=-r,n[10]=_,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1}(_n,nn),function(n,t){n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1}(an,[Z,J,Q]),i(en,rn,_n),i(en,an,en),o(en,en),i(on,tn,en),o(on,on),L.uniform1f(L.getUniformLocation(I,"near"),Y),L.uniform1f(L.getUniformLocation(I,"far"),j),L.uniformMatrix4fv(L.getUniformLocation(I,"invprojview"),!1,on)}function vn(){for(var n=[],t=0;t<f.Rm.length;t++)f.Rm[t].enabled&&n.push(f.Rm[t]);var r=n.length;L.uniform1i(L.getUniformLocation(I,"numPlanes"),r);for(var _=0;_<r;_++){var a=L.getUniformLocation(I,"planeOffsets["+_+"]"),e=L.getUniformLocation(I,"planeNormals["+_+"]"),o=L.getUniformLocation(I,"planeColors["+_+"]"),i=L.getUniformLocation(I,"planeSpecular["+_+"]"),p=L.getUniformLocation(I,"planeRoughness["+_+"]");L.uniform1f(a,n[_].offset),L.uniform3f(e,n[_].x,n[_].y,n[_].z),L.uniform3f(o,n[_].r,n[_].g,n[_].b),L.uniform1f(i,n[_].specular),L.uniform1f(p,n[_].roughness)}}function ln(){var n=f.H.filter((function(n){return n.enabled})),t=n.length;L.uniform1i(L.getUniformLocation(I,"numLights"),t);for(var r=0;r<t;r++){var _=n[r],a=L.getUniformLocation(I,"lightPos["+r+"]"),e=L.getUniformLocation(I,"lightSize["+r+"]"),o=L.getUniformLocation(I,"lightBrightness["+r+"]"),i=L.getUniformLocation(I,"lightSpot["+r+"]");L.uniform3f(a,_.x,_.y,_.z),L.uniform2f(e,G?_.sizeX:0,G?_.sizeY:0),L.uniform3f(o,_.r*_.brightness,_.g*_.brightness,_.b*_.brightness),L.uniform2f(i,_.spotSize,_.spotIntensity)}}function sn(){L.uniform3f(L.getUniformLocation(I,"ambientLight"),.01,.01,.01),L.uniform1i(L.getUniformLocation(I,"enableGI"),U),L.uniform1i(L.getUniformLocation(I,"enableRefGI"),F),L.uniform1i(L.getUniformLocation(I,"indirectSamples"),D),L.uniform1i(L.getUniformLocation(I,"rayBounces"),q);var n=Math.floor(Math.sqrt(O));L.uniform1f(L.getUniformLocation(I,"shadowDim"),n),L.uniform1i(L.getUniformLocation(I,"shadowSamples"),Math.pow(n,2)),L.uniform1i(L.getUniformLocation(I,"enablePlaneBacksides"),V),L.uniform1i(L.getUniformLocation(I,"enablePlaneMirrors"),X),L.uniform2f(L.getUniformLocation(I,"attenuationFactor"),H,W)}function fn(){E.style.width=window.innerWidth,E.style.height=window.innerHeight;var n=Math.floor(window.innerWidth*window.devicePixelRatio),t=Math.floor(window.innerHeight*window.devicePixelRatio);L.bindTexture(L.TEXTURE_2D,A),L.texImage2D(L.TEXTURE_2D,0,L.RGBA,n,t,0,L.RGBA,L.UNSIGNED_BYTE,null),L.bindTexture(L.TEXTURE_2D,null),L.bindTexture(L.TEXTURE_2D,B),L.texImage2D(L.TEXTURE_2D,0,L.RGBA,n,t,0,L.RGBA,L.UNSIGNED_BYTE,null),L.bindTexture(L.TEXTURE_2D,null),v(L,n,t),mn()}function cn(n,t){var r=document.getElementById("lightcontrols"),_="\n        <br>\n        <b>light ".concat(n+1,'</b><br>\n        <input type="checkbox" ').concat(t[n].enabled&&"checked",' id="').concat(n,'" class="light-enable"> on/off<br>\n        <table class="sliders">\n            <tr>\n                <td><label>Bright:</label></td>\n                <td><input type="range" min="0" max="200" step="0.1" value="').concat(t[n].brightness,'" id="').concat(n,'" class="light-brightness"></td>\n            </tr>\n            <tr>\n                <td><label>Spot size:</label></td>\n                <td><input type="range" min="0" max="1" step="0.01" value="').concat(1-t[n].spotSize,'" id="').concat(n,'" class="light-spotsize"></td>\n            </tr>\n            <tr>\n                <td><label>Spot falloff:</label></td>\n                <td><input type="range" min="0" max="4" step="0.01" value="').concat(t[n].spotIntensity,'" id="').concat(n,'" class="light-spotintensity"></td>\n            </tr>\n            <tr>\n                <td><label>r:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'r" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>g:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'g" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>b:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'b" class="light-color"></td>\n            </tr>\n                <td><label>sizeX:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(t[n].sizeX,'" id="').concat(n,'x" class="light-size"></td>\n            <tr>\n                <td><label>sizeY:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(t[n].sizeY,'" id="').concat(n,'y" class="light-size"></td>\n            </tr>\n        </table>');r.insertAdjacentHTML("beforeend",_)}function hn(n,t){var r=document.getElementById("planecontrols"),_='\n        <input type="checkbox" id="'.concat(n,'" class="plane-enable" ').concat(t[n].enabled&&"checked","><b>").concat(t[n].desc,"</b><br>");r.insertAdjacentHTML("beforeend",_)}fn(),vn(),function(){var n=f.vi.length;L.uniform1i(L.getUniformLocation(I,"numSpheres"),n);for(var t=0;t<n;t++){var r=f.vi[t],_=L.getUniformLocation(I,"sphereCenters["+t+"]"),a=L.getUniformLocation(I,"sphereColors["+t+"]"),e=L.getUniformLocation(I,"reflectiveColors["+t+"]"),o=L.getUniformLocation(I,"sphereSpecColors["+t+"]"),i=L.getUniformLocation(I,"sphereRoughness["+t+"]");L.uniform3f(_,r.x,r.y,r.z),L.uniform3f(a,r.r,r.g,r.b),L.uniform3f(e,r.rr,r.rg,r.rb),L.uniform3f(o,r.sr,r.sg,r.sb),L.uniform1f(i,r.roughness)}}(),ln(),sn(),function n(t){var r,a,e,o,i;if(S=(t=.001*(t||0))-P,P=t,w+=1/S,50==(z+=1)&&(c.innerText=Math.floor(w/50),w=0,z=1),u=d,(g||b||y||x||C)&&(mn(S),g=!1,u=!1),u&&(r=1/L.canvas.width,a=1/L.canvas.height,0,0,0,0,0,0,0,0,0,0,0,0,e=(1.5*Math.random()-.75)*r,o=(1.5*Math.random()-.75)*a,0,0,(i=new _(16))[0]=0,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=0,i[11]=0,i[12]=e,i[13]=o,i[14]=0,i[15]=0,function(n,t,r){n[0]=t[0]+r[0],n[1]=t[1]+r[1],n[2]=t[2]+r[2],n[3]=t[3]+r[3],n[4]=t[4]+r[4],n[5]=t[5]+r[5],n[6]=t[6]+r[6],n[7]=t[7]+r[7],n[8]=t[8]+r[8],n[9]=t[9]+r[9],n[10]=t[10]+r[10],n[11]=t[11]+r[11],n[12]=t[12]+r[12],n[13]=t[13]+r[13],n[14]=t[14]+r[14],n[15]=t[15]+r[15]}(pn,on,i),L.uniformMatrix4fv(L.getUniformLocation(I,"invprojview"),!1,pn)),L.uniform1i(k,u),L.uniform1f(R,Math.random()),d){var p=h?N:M;L.bindFramebuffer(L.DRAW_FRAMEBUFFER,p),L.bindTexture(L.TEXTURE_2D,h?B:A),L.clearColor(0,0,0,1),L.clear(L.COLOR_BUFFER_BIT),L.uniform1i(T,0),L.drawArrays(L.TRIANGLES,0,3),L.bindFramebuffer(L.READ_FRAMEBUFFER,p),L.bindFramebuffer(L.DRAW_FRAMEBUFFER,null),L.blitFramebuffer(0,0,L.canvas.width,L.canvas.height,0,0,L.canvas.width,L.canvas.height,L.COLOR_BUFFER_BIT,L.NEAREST),h=!h}else L.bindFramebuffer(L.DRAW_FRAMEBUFFER,null),L.drawArrays(L.TRIANGLES,0,3);requestAnimationFrame(n)}();for(var dn=0;dn<f.H.length;dn++)cn(dn,f.H);for(var un=0;un<f.Rm.length;un++)hn(un,f.Rm);function gn(n,t){switch(n){case"KeyW":b=t;break;case"KeyS":x=t;break;case"KeyA":y=t;break;case"KeyD":C=t}}window.addEventListener("resize",fn),document.addEventListener("mousedown",(function(n){n.target.closest(".controls")||2==n.button&&(document.pointerLockElement===n.target?document.exitPointerLock():n.target.requestPointerLock())})),document.addEventListener("mousemove",(function(n){var t;"canvas"===(null===(t=document.pointerLockElement)||void 0===t?void 0:t.id)&&($-=.0015*n.movementX,nn-=.0015*n.movementY,g=!0)})),document.addEventListener("keydown",(function(n){return gn(n.code,!0)})),document.addEventListener("keyup",(function(n){return gn(n.code,!1)})),document.getElementById("enableTAA").addEventListener("input",(function(n){d=n.target.checked,fn()})),document.getElementById("enableGI").addEventListener("input",(function(n){U=n.target.checked,sn()})),document.getElementById("enableRefGI").addEventListener("input",(function(n){F=n.target.checked,sn()})),document.getElementById("indirectsamples").addEventListener("input",(function(n){D=n.target.value,sn()})),document.getElementById("directsamples").addEventListener("input",(function(n){O=n.target.value*n.target.value,sn()})),document.getElementById("reflectionbounces").addEventListener("input",(function(n){q=n.target.value,sn()})),document.getElementById("fov").addEventListener("input",(function(n){var t;t=n.target.value,K=t*a,mn()})),document.getElementById("arealightsenable").addEventListener("input",(function(n){G=n.target.checked,ln()})),document.querySelectorAll(".attenuation").forEach((function(n){n.addEventListener("input",(function(n){"quadratic"===n.target.id?H=n.target.value:"linear"===n.target.id&&(W=n.target.value),sn()}))})),document.querySelectorAll(".light-enable").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].enabled=n.target.checked,ln()}))})),document.querySelectorAll(".light-brightness").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].brightness=n.target.value,ln()}))})),document.querySelectorAll(".light-spotsize").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].spotSize=1-n.target.value,ln()}))})),document.querySelectorAll(".light-spotintensity").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].spotIntensity=n.target.value,ln()}))})),document.querySelectorAll(".light-color").forEach((function(n){n.addEventListener("input",(function(n){var t=f.H[n.target.id[0]];"r"===n.target.id[1]?t.r=n.target.value:"g"===n.target.id[1]?t.g=n.target.value:"b"===n.target.id[1]&&(t.b=n.target.value),ln()}))})),document.querySelectorAll(".light-size").forEach((function(n){n.addEventListener("input",(function(n){var t=f.H[n.target.id[0]];"x"===n.target.id[1]?t.sizeX=n.target.value:"y"===n.target.id[1]&&(t.sizeY=n.target.value),ln()}))})),document.querySelectorAll(".plane-enable").forEach((function(n){n.addEventListener("input",(function(n){f.Rm[n.target.id].enabled=n.target.checked,vn()}))})),document.getElementById("planebacksides").addEventListener("input",(function(n){V=n.target.checked,sn()})),document.getElementById("enablemirrorworld").addEventListener("input",(function(n){X=n.target.checked,sn()}))},424:(n,t,r)=>{r.d(t,{Z:()=>i});var _=r(81),a=r.n(_),e=r(645),o=r.n(e)()(a());o.push([n.id,"/* ----- COLORS ----- */\r\n:root {\r\n    --blue: #007bff;\r\n    /*--blue: #2e5bff;*/\r\n    --darkblue: #1374dc;\r\n    --blue-neon: #0dffff;\r\n    --teal: #11cdef;\r\n    --lightgreen: #00d774;\r\n    --orange: #fd7e14;\r\n    --darkorange: #e07217;\r\n    --gray1: #f4f5f7;\r\n    --gray2: #e2e6ea;\r\n    --gray3: #6c757d;\r\n    --gray4: #343a40;\r\n    --green: #28a745;\r\n    --green-dark: #1c8935;\r\n    --red: #dc3545;\r\n    --red-dark: #c42e3d;\r\n    --red-bright: #ff3355;\r\n    --red-light: #ff6384;\r\n    --purple-light: #5e72e4;\r\n    --purple: #6f42c1;\r\n    --purple-dark: rgb(112, 48, 160);\r\n}\r\n/*------------------------*/\r\n\r\nhtml {\r\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n}\r\n\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    background-color: rgb(40, 40, 40);\r\n    overflow: hidden;\r\n}\r\n/*\r\ncanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n*/\r\n.controls {\r\n    position: absolute;\r\n    top: 1em;\r\n    right: 1em;\r\n    width: 250px;\r\n    padding: 0 0.2em 1em 1em;\r\n    background-color: rgb(255 255 255 / 60%);\r\n    border-radius: 15px;\r\n    max-height: 95%;\r\n    overflow-y: scroll;\r\n    overflow-x: hidden;\r\n}\r\n\r\n.controls::-webkit-scrollbar-track {\r\n    /*-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);*/\r\n \t/*border-radius: 10px;*/\r\n}\r\n.controls::-webkit-scrollbar {\r\n \twidth: 1em;\r\n}\r\n.controls::-webkit-scrollbar-thumb {\r\n    background-color: var(--blue);\r\n    border: 5px solid transparent;\r\n    border-radius: 15px;\r\n    background-clip: padding-box;\r\n}\r\n.controls::-webkit-scrollbar-thumb:hover {\r\n\tbackground-color: var(--darkblue);\r\n}\r\n\r\n.controls .section {\r\n    border-bottom: solid 1px rgb(255 255 255 / 60%);\r\n    margin: 1em 0 0 0;\r\n    padding: 0 0 1em;\r\n}\r\n\r\n.controls h3 {\r\n    padding: 0;\r\n    margin: 0 0 0.5em 0;\r\n    color: #005aff;\r\n    font-weight: 600;\r\n}\r\n\r\n.controls output {\r\n    color: #005aff;\r\n}\r\n\r\n.controls .deg-sign {\r\n    color: #005aff;\r\n}\r\n\r\n.controls .slider_container {\r\n    display: flex;\r\n    flex-direction: row;\r\n    align-items: center;\r\n}\r\n\r\ntable.sliders {\r\n    width: 100%;\r\n}\r\n\r\n.sliders input {\r\n    width: 100%;\r\n}\r\n\r\n#fps-container {\r\n    position: absolute;\r\n    top: 1em;\r\n    left: 1em;\r\n    color: white;\r\n}\r\n\r\n/* ----- Toggle switch ----- */\r\n/* The switch - the box around the slider */\r\n.switch {\r\n    position: relative;\r\n  }\r\n  /* Hide default HTML checkbox */\r\n  .switch input {\r\n    position: absolute;\r\n    opacity: 0;\r\n    width: 0;\r\n    height: 0;\r\n  }\r\n  /* The slider */\r\n  .slider {\r\n    border-radius: 10px;\r\n    position: relative;\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    vertical-align: middle;\r\n    height: 15px;\r\n    width: 34px;\r\n    background-color: var(--gray2);\r\n    -webkit-transition: 0.4s;\r\n    transition: 0.4s;\r\n  }\r\n  .slider:before {\r\n    position: absolute;\r\n    content: \"\";\r\n    height: 11px;\r\n    width: 11px;\r\n    left: 3px;\r\n    bottom: 2px;\r\n    background-color: white;\r\n    -webkit-transition: 0.4s;\r\n    transition: 0.4s;\r\n    box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.21);\r\n    border-radius: 5px;\r\n  }\r\n  input:checked + .slider {\r\n    background-color: var(--blue);\r\n  }\r\n  input:checked + .slider.del {\r\n    background-color: var(--red-bright);\r\n  }\r\n  input:checked + .slider:before {\r\n    transform: translateX(17px);\r\n  }\r\n  /* ----------------------- */",""]);const i=o},645:n=>{n.exports=function(n){var t=[];return t.toString=function(){return this.map((function(t){var r="",_=void 0!==t[5];return t[4]&&(r+="@supports (".concat(t[4],") {")),t[2]&&(r+="@media ".concat(t[2]," {")),_&&(r+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),r+=n(t),_&&(r+="}"),t[2]&&(r+="}"),t[4]&&(r+="}"),r})).join("")},t.i=function(n,r,_,a,e){"string"==typeof n&&(n=[[null,n,void 0]]);var o={};if(_)for(var i=0;i<this.length;i++){var p=this[i][0];null!=p&&(o[p]=!0)}for(var m=0;m<n.length;m++){var v=[].concat(n[m]);_&&o[v[0]]||(void 0!==e&&(void 0===v[5]||(v[1]="@layer".concat(v[5].length>0?" ".concat(v[5]):""," {").concat(v[1],"}")),v[5]=e),r&&(v[2]?(v[1]="@media ".concat(v[2]," {").concat(v[1],"}"),v[2]=r):v[2]=r),a&&(v[4]?(v[1]="@supports (".concat(v[4],") {").concat(v[1],"}"),v[4]=a):v[4]="".concat(a)),t.push(v))}},t}},81:n=>{n.exports=function(n){return n[1]}},548:(n,t,r)=>{var _=r(379),a=r.n(_),e=r(795),o=r.n(e),i=r(569),p=r.n(i),m=r(565),v=r.n(m),l=r(216),s=r.n(l),f=r(589),c=r.n(f),h=r(424),d={};d.styleTagTransform=c(),d.setAttributes=v(),d.insert=p().bind(null,"head"),d.domAPI=o(),d.insertStyleElement=s(),a()(h.Z,d),h.Z&&h.Z.locals&&h.Z.locals},379:n=>{var t=[];function r(n){for(var r=-1,_=0;_<t.length;_++)if(t[_].identifier===n){r=_;break}return r}function _(n,_){for(var e={},o=[],i=0;i<n.length;i++){var p=n[i],m=_.base?p[0]+_.base:p[0],v=e[m]||0,l="".concat(m," ").concat(v);e[m]=v+1;var s=r(l),f={css:p[1],media:p[2],sourceMap:p[3],supports:p[4],layer:p[5]};if(-1!==s)t[s].references++,t[s].updater(f);else{var c=a(f,_);_.byIndex=i,t.splice(i,0,{identifier:l,updater:c,references:1})}o.push(l)}return o}function a(n,t){var r=t.domAPI(t);return r.update(n),function(t){if(t){if(t.css===n.css&&t.media===n.media&&t.sourceMap===n.sourceMap&&t.supports===n.supports&&t.layer===n.layer)return;r.update(n=t)}else r.remove()}}n.exports=function(n,a){var e=_(n=n||[],a=a||{});return function(n){n=n||[];for(var o=0;o<e.length;o++){var i=r(e[o]);t[i].references--}for(var p=_(n,a),m=0;m<e.length;m++){var v=r(e[m]);0===t[v].references&&(t[v].updater(),t.splice(v,1))}e=p}}},569:n=>{var t={};n.exports=function(n,r){var _=function(n){if(void 0===t[n]){var r=document.querySelector(n);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(n){r=null}t[n]=r}return t[n]}(n);if(!_)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");_.appendChild(r)}},216:n=>{n.exports=function(n){var t=document.createElement("style");return n.setAttributes(t,n.attributes),n.insert(t,n.options),t}},565:(n,t,r)=>{n.exports=function(n){var t=r.nc;t&&n.setAttribute("nonce",t)}},795:n=>{n.exports=function(n){var t=n.insertStyleElement(n);return{update:function(r){!function(n,t,r){var _="";r.supports&&(_+="@supports (".concat(r.supports,") {")),r.media&&(_+="@media ".concat(r.media," {"));var a=void 0!==r.layer;a&&(_+="@layer".concat(r.layer.length>0?" ".concat(r.layer):""," {")),_+=r.css,a&&(_+="}"),r.media&&(_+="}"),r.supports&&(_+="}");var e=r.sourceMap;e&&"undefined"!=typeof btoa&&(_+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(e))))," */")),t.styleTagTransform(_,n,t.options)}(t,n,r)},remove:function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(t)}}}},589:n=>{n.exports=function(n,t){if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}},574:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nfloat randomIncrement;\nuniform float randomseed;\nuniform highp int numLights;\nuniform vec3 lightPos[2];\nuniform vec2 lightSize[2];\nuniform vec3 lightBrightness[2];\nuniform vec2 lightSpot[2];\nuniform highp int shadowSamples;\nuniform float shadowDim;\nuniform vec2 attenuationFactor;\nuniform highp int numSpheres;\nuniform vec3 sphereCenters[4];\nuniform vec3 sphereColors[4];\nuniform vec3 reflectiveColors[4];\nuniform vec3 sphereSpecColors[4];\nuniform float sphereRoughness[4];\nuniform highp int numPlanes;\nuniform float planeOffsets[6];\nuniform vec3 planeNormals[6];\nuniform vec3 planeColors[6];\nuniform float planeSpecular[6];\nuniform float planeRoughness[6];\nuniform highp int rayBounces;\nuniform vec3 ambientLight;\nuniform bool enableGI;\nuniform bool enableRefGI;\nuniform highp int indirectSamples;\nuniform bool enablePlaneBacksides;\nuniform bool enablePlaneMirrors;\nuniform bool enableTAA;\nuniform sampler2D u_texture;\nin vec3 origin;\nin vec3 ray;\nin vec2 texCoord;\nout lowp vec4 fragColor;\nvoid main ()\n{\n  float roughness_1;\n  vec3 reflectiveColor_2;\n  vec3 specularColor_3;\n  vec3 diffuseColor_4;\n  lowp vec3 pixelColor_5;\n  vec3 tmpvar_6;\n  tmpvar_6 = normalize(ray);\n  randomIncrement = randomseed;\n  vec3 ray_origin_7;\n  ray_origin_7 = origin;\n  vec3 ray_direction_8;\n  ray_direction_8 = tmpvar_6;\n  float t_hit_9;\n  t_hit_9 = sqrt(dot (ray, ray));\n  vec3 position_10;\n  vec3 normal_11;\n  vec3 diffuseColor_12;\n  diffuseColor_12 = diffuseColor_4;\n  vec3 specularColor_13;\n  specularColor_13 = specularColor_3;\n  vec3 reflectiveColor_14;\n  reflectiveColor_14 = reflectiveColor_2;\n  float roughness_15;\n  roughness_15 = roughness_1;\n  bool intersectLight_16;\n  intersectLight_16 = bool(1);\n  highp int idx_19;\n  highp int intersected_20;\n  intersected_20 = 0;\n  idx_19 = 0;\n  for (highp int i_18 = 0; i_18 < numSpheres; i_18++) {\n    float t_hit_21;\n    t_hit_21 = t_hit_9;\n    bool tmpvar_22;\n    vec3 tmpvar_23;\n    tmpvar_23 = (sphereCenters[i_18] - ray_origin_7);\n    float tmpvar_24;\n    tmpvar_24 = dot (tmpvar_23, ray_direction_8);\n    if ((tmpvar_24 < 0.0)) {\n      tmpvar_22 = bool(0);\n    } else {\n      float tmpvar_25;\n      tmpvar_25 = (dot (tmpvar_23, tmpvar_23) - (tmpvar_24 * tmpvar_24));\n      if ((tmpvar_25 > 0.64)) {\n        tmpvar_22 = bool(0);\n      } else {\n        float tmpvar_26;\n        tmpvar_26 = sqrt((0.64 - tmpvar_25));\n        float tmpvar_27;\n        tmpvar_27 = (tmpvar_24 - tmpvar_26);\n        float tmpvar_28;\n        tmpvar_28 = (tmpvar_24 + tmpvar_26);\n        float tmpvar_29;\n        if ((tmpvar_27 < 0.0)) {\n          tmpvar_29 = tmpvar_28;\n        } else {\n          tmpvar_29 = tmpvar_27;\n        };\n        if (((tmpvar_29 < t_hit_9) && (tmpvar_29 > 0.0))) {\n          t_hit_21 = tmpvar_29;\n          tmpvar_22 = bool(1);\n        } else {\n          tmpvar_22 = bool(0);\n        };\n      };\n    };\n    t_hit_9 = t_hit_21;\n    if (tmpvar_22) {\n      idx_19 = i_18;\n      intersected_20 = 1;\n    };\n  };\n  for (highp int i_17 = 0; i_17 < numPlanes; i_17++) {\n    vec3 tmpvar_30;\n    tmpvar_30 = planeNormals[i_17];\n    bool tmpvar_31;\n    if (enablePlaneBacksides) {\n      tmpvar_31 = bool(1);\n    } else {\n      tmpvar_31 = (dot (ray_direction_8, tmpvar_30) < 0.0);\n    };\n    if (tmpvar_31) {\n      float t_hit_32;\n      t_hit_32 = t_hit_9;\n      bool tmpvar_33;\n      tmpvar_33 = bool(1);\n      bool tmpvar_34;\n      vec3 tmpvar_35;\n      tmpvar_35 = (tmpvar_30 * planeOffsets[i_17]);\n      float tmpvar_36;\n      tmpvar_36 = (((\n        (tmpvar_35.x + tmpvar_35.y)\n       + tmpvar_35.z) - dot (tmpvar_30, ray_origin_7)) / dot (tmpvar_30, ray_direction_8));\n      if (((tmpvar_36 < t_hit_9) && (tmpvar_36 > 0.0))) {\n        t_hit_32 = tmpvar_36;\n        tmpvar_34 = bool(1);\n        tmpvar_33 = bool(0);\n      };\n      if (tmpvar_33) {\n        tmpvar_34 = bool(0);\n        tmpvar_33 = bool(0);\n      };\n      t_hit_9 = t_hit_32;\n      if (tmpvar_34) {\n        normal_11 = tmpvar_30;\n        idx_19 = i_17;\n        intersected_20 = 2;\n      };\n    };\n  };\n  intersectLight_16 = bool(0);\n  for (highp int i_37 = 0; i_37 < numLights; i_37++) {\n    bool tmp_38;\n    vec3 tmpvar_39;\n    tmpvar_39 = lightPos[i_37];\n    vec2 tmpvar_40;\n    tmpvar_40 = lightSize[i_37];\n    tmp_38 = bool(0);\n    if (((tmpvar_40.x > 0.0) && (tmpvar_40.y > 0.0))) {\n      float t_hit_41;\n      t_hit_41 = t_hit_9;\n      bool tmpvar_42;\n      tmpvar_42 = bool(1);\n      bool tmpvar_43;\n      vec3 tmpvar_44;\n      tmpvar_44 = (vec3(0.0, 1.0, 0.0) * tmpvar_39.y);\n      float tmpvar_45;\n      tmpvar_45 = (((\n        (tmpvar_44.x + tmpvar_44.y)\n       + tmpvar_44.z) - ray_origin_7.y) / ray_direction_8.y);\n      if (((tmpvar_45 < t_hit_9) && (tmpvar_45 > 0.0))) {\n        vec3 tmpvar_46;\n        tmpvar_46 = (ray_origin_7 + (ray_direction_8 * tmpvar_45));\n        if ((((tmpvar_40.x + tmpvar_40.y) == 0.0) || ((\n          ((tmpvar_46.x < (tmpvar_39.x + (tmpvar_40.x * 0.5))) && (tmpvar_46.x > (tmpvar_39.x - (tmpvar_40.x * 0.5))))\n         && \n          (tmpvar_46.z < (tmpvar_39.z + (tmpvar_40.y * 0.5)))\n        ) && (tmpvar_46.z > \n          (tmpvar_39.z - (tmpvar_40.y * 0.5))\n        )))) {\n          t_hit_41 = tmpvar_45;\n          tmpvar_43 = bool(1);\n          tmpvar_42 = bool(0);\n        };\n      };\n      if (tmpvar_42) {\n        tmpvar_43 = bool(0);\n        tmpvar_42 = bool(0);\n      };\n      t_hit_9 = t_hit_41;\n      tmp_38 = tmpvar_43;\n    } else {\n      float t_hit_47;\n      t_hit_47 = t_hit_9;\n      bool tmpvar_48;\n      vec3 tmpvar_49;\n      tmpvar_49 = (tmpvar_39 - ray_origin_7);\n      float tmpvar_50;\n      tmpvar_50 = dot (tmpvar_49, ray_direction_8);\n      if ((tmpvar_50 < 0.0)) {\n        tmpvar_48 = bool(0);\n      } else {\n        float tmpvar_51;\n        tmpvar_51 = (dot (tmpvar_49, tmpvar_49) - (tmpvar_50 * tmpvar_50));\n        if ((tmpvar_51 > 0.01)) {\n          tmpvar_48 = bool(0);\n        } else {\n          float tmpvar_52;\n          tmpvar_52 = sqrt((0.01 - tmpvar_51));\n          float tmpvar_53;\n          tmpvar_53 = (tmpvar_50 - tmpvar_52);\n          float tmpvar_54;\n          tmpvar_54 = (tmpvar_50 + tmpvar_52);\n          float tmpvar_55;\n          if ((tmpvar_53 < 0.0)) {\n            tmpvar_55 = tmpvar_54;\n          } else {\n            tmpvar_55 = tmpvar_53;\n          };\n          if (((tmpvar_55 < t_hit_9) && (tmpvar_55 > 0.0))) {\n            t_hit_47 = tmpvar_55;\n            tmpvar_48 = bool(1);\n          } else {\n            tmpvar_48 = bool(0);\n          };\n        };\n      };\n      t_hit_9 = t_hit_47;\n      tmp_38 = tmpvar_48;\n    };\n    if (tmp_38) {\n      idx_19 = i_37;\n      intersected_20 = 3;\n    };\n  };\n  position_10 = (origin + (tmpvar_6 * t_hit_9));\n  if ((intersected_20 == 1)) {\n    diffuseColor_12 = sphereColors[idx_19];\n    specularColor_13 = sphereSpecColors[idx_19];\n    reflectiveColor_14 = reflectiveColors[idx_19];\n    roughness_15 = sphereRoughness[idx_19];\n    vec3 tmpvar_56;\n    tmpvar_56 = normalize((position_10 - sphereCenters[idx_19]));\n    normal_11 = tmpvar_56;\n    float tmpvar_57;\n    tmpvar_57 = dot (tmpvar_56, -(tmpvar_6));\n    if ((tmpvar_57 < 0.0)) {\n      normal_11 = -(tmpvar_56);\n    };\n  } else {\n    if ((intersected_20 == 2)) {\n      if (!(enablePlaneMirrors)) {\n        diffuseColor_12 = planeColors[idx_19];\n        specularColor_13 = vec3(planeSpecular[idx_19]);\n        reflectiveColor_14 = vec3(0.0, 0.0, 0.0);\n        roughness_15 = planeRoughness[idx_19];\n      } else {\n        diffuseColor_12 = (planeColors[idx_19] * 0.01);\n        specularColor_13 = vec3(0.0, 0.0, 0.0);\n        reflectiveColor_14 = planeColors[idx_19];\n        roughness_15 = 1.0;\n      };\n      float tmpvar_58;\n      tmpvar_58 = dot (normal_11, -(tmpvar_6));\n      if ((tmpvar_58 < 0.0)) {\n        normal_11 = -(normal_11);\n      };\n    } else {\n      if ((intersected_20 == 3)) {\n        float spot_falloff_59;\n        spot_falloff_59 = 1.0;\n        vec2 tmpvar_60;\n        tmpvar_60 = lightSpot[idx_19];\n        if ((tmpvar_60.x > 0.0)) {\n          float tmpvar_61;\n          if ((tmpvar_6.y > tmpvar_60.x)) {\n            tmpvar_61 = pow (tmpvar_6.y, tmpvar_60.y);\n          } else {\n            tmpvar_61 = 0.0;\n          };\n          spot_falloff_59 = tmpvar_61;\n        };\n        diffuseColor_12 = ((spot_falloff_59 * lightBrightness[idx_19]) * 0.2);\n        intersectLight_16 = bool(1);\n      };\n    };\n  };\n  diffuseColor_4 = diffuseColor_12;\n  specularColor_3 = specularColor_13;\n  reflectiveColor_2 = reflectiveColor_14;\n  roughness_1 = roughness_15;\n  if (intersectLight_16) {\n    lowp vec4 tmpvar_62;\n    tmpvar_62.w = 1.0;\n    tmpvar_62.xyz = diffuseColor_12;\n    fragColor = tmpvar_62;\n    return;\n  };\n  if (!(enableGI)) {\n    pixelColor_5 = (pixelColor_5 + (ambientLight * diffuseColor_12));\n  };\n  vec3 P_63;\n  P_63 = position_10;\n  vec3 V_64;\n  V_64 = tmpvar_6;\n  vec3 N_65;\n  N_65 = normal_11;\n  vec3 diffuseColor_66;\n  diffuseColor_66 = diffuseColor_12;\n  vec3 specularColor_67;\n  specularColor_67 = specularColor_13;\n  vec3 illuminationColor_69;\n  for (highp int i_68 = 0; i_68 < numLights; i_68++) {\n    highp int k_70;\n    bool inShade_71;\n    highp int areaShadowSamples_72;\n    highp int testSamples_73;\n    vec3 light_sum_74;\n    vec2 lightSpot_75;\n    vec2 lightSize_76;\n    vec3 lightBrightness_77;\n    vec3 lightPos_78;\n    lightPos_78 = lightPos[i_68];\n    lightBrightness_77 = lightBrightness[i_68];\n    vec2 tmpvar_79;\n    tmpvar_79 = lightSize[i_68];\n    lightSize_76 = tmpvar_79;\n    lightSpot_75 = lightSpot[i_68];\n    bool tmpvar_80;\n    tmpvar_80 = ((tmpvar_79.x > 0.0) && (tmpvar_79.y > 0.0));\n    highp int tmpvar_81;\n    if (tmpvar_80) {\n      tmpvar_81 = 5;\n    } else {\n      tmpvar_81 = 1;\n    };\n    testSamples_73 = tmpvar_81;\n    areaShadowSamples_72 = 0;\n    inShade_71 = bool(0);\n    k_70 = 0;\n    while (true) {\n      vec3 testPos_82;\n      if ((k_70 >= testSamples_73)) {\n        break;\n      };\n      if (inShade_71) {\n        break;\n      };\n      testPos_82 = lightPos_78;\n      if ((k_70 == 1)) {\n        testPos_82.x = (lightPos_78.x - (lightSize_76.x * 0.5));\n        testPos_82.z = (lightPos_78.z - (lightSize_76.y * 0.5));\n      } else {\n        if ((k_70 == 2)) {\n          testPos_82.x = (testPos_82.x + (lightSize_76.x * 0.5));\n          testPos_82.z = (testPos_82.z + (lightSize_76.y * 0.5));\n        } else {\n          if ((k_70 == 3)) {\n            testPos_82.x = (testPos_82.x + (lightSize_76.x * 0.5));\n            testPos_82.z = (testPos_82.z - (lightSize_76.y * 0.5));\n          } else {\n            if ((k_70 == 4)) {\n              testPos_82.x = (testPos_82.x - (lightSize_76.x * 0.5));\n              testPos_82.z = (testPos_82.z + (lightSize_76.y * 0.5));\n            };\n          };\n        };\n      };\n      vec3 L_83;\n      vec3 incidentIntensity_84;\n      float falloff_85;\n      L_83 = (testPos_82 - P_63);\n      float tmpvar_86;\n      tmpvar_86 = sqrt(dot (L_83, L_83));\n      float tmpvar_87;\n      tmpvar_87 = (1.0/(((attenuationFactor.x * \n        (tmpvar_86 * tmpvar_86)\n      ) + (attenuationFactor.y * tmpvar_86))));\n      vec3 tmpvar_88;\n      tmpvar_88 = normalize(L_83);\n      L_83 = tmpvar_88;\n      falloff_85 = 1.0;\n      if ((lightSpot_75.x > 0.0)) {\n        float tmpvar_89;\n        if ((tmpvar_88.y > lightSpot_75.x)) {\n          tmpvar_89 = pow (tmpvar_88.y, lightSpot_75.y);\n        } else {\n          tmpvar_89 = 0.0;\n        };\n        falloff_85 = tmpvar_89;\n      };\n      incidentIntensity_84 = ((lightBrightness_77 * tmpvar_87) * falloff_85);\n      float tmpvar_90;\n      tmpvar_90 = dot (N_65, tmpvar_88);\n      if (((tmpvar_90 > 0.0) && ((\n        (incidentIntensity_84.x + incidentIntensity_84.y)\n       + incidentIntensity_84.z) > 0.01))) {\n        vec3 ray_origin_91;\n        ray_origin_91 = P_63;\n        vec3 ray_direction_92;\n        ray_direction_92 = tmpvar_88;\n        float t_hit_93;\n        t_hit_93 = tmpvar_86;\n        bool tmpvar_94;\n        tmpvar_94 = bool(0);\n        highp int i_95;\n        highp int i_96;\n        i_96 = 0;\n        while (true) {\n          if ((i_96 >= numSpheres)) {\n            break;\n          };\n          float t_hit_97;\n          t_hit_97 = t_hit_93;\n          bool tmpvar_98;\n          vec3 tmpvar_99;\n          tmpvar_99 = (sphereCenters[i_96] - ray_origin_91);\n          float tmpvar_100;\n          tmpvar_100 = dot (tmpvar_99, ray_direction_92);\n          if ((tmpvar_100 < 0.0)) {\n            tmpvar_98 = bool(0);\n          } else {\n            float tmpvar_101;\n            tmpvar_101 = (dot (tmpvar_99, tmpvar_99) - (tmpvar_100 * tmpvar_100));\n            if ((tmpvar_101 > 0.64)) {\n              tmpvar_98 = bool(0);\n            } else {\n              float tmpvar_102;\n              tmpvar_102 = sqrt((0.64 - tmpvar_101));\n              float tmpvar_103;\n              tmpvar_103 = (tmpvar_100 - tmpvar_102);\n              float tmpvar_104;\n              tmpvar_104 = (tmpvar_100 + tmpvar_102);\n              float tmpvar_105;\n              if ((tmpvar_103 < 0.001)) {\n                tmpvar_105 = tmpvar_104;\n              } else {\n                tmpvar_105 = tmpvar_103;\n              };\n              if (((tmpvar_105 < t_hit_93) && (tmpvar_105 > 0.001))) {\n                t_hit_97 = tmpvar_105;\n                tmpvar_98 = bool(1);\n              } else {\n                tmpvar_98 = bool(0);\n              };\n            };\n          };\n          t_hit_93 = t_hit_97;\n          if (tmpvar_98) {\n            tmpvar_94 = bool(1);\n            break;\n          };\n          i_96++;\n        };\n        if (!(tmpvar_94)) {\n          i_95 = 0;\n          while (true) {\n            if ((i_95 >= numPlanes)) {\n              break;\n            };\n            vec3 normal_106;\n            normal_106 = planeNormals[i_95];\n            float t_hit_107;\n            t_hit_107 = t_hit_93;\n            bool tmpvar_108;\n            tmpvar_108 = bool(1);\n            bool tmpvar_109;\n            vec3 tmpvar_110;\n            tmpvar_110 = (normal_106 * planeOffsets[i_95]);\n            float tmpvar_111;\n            tmpvar_111 = (((\n              (tmpvar_110.x + tmpvar_110.y)\n             + tmpvar_110.z) - dot (normal_106, ray_origin_91)) / dot (normal_106, ray_direction_92));\n            if (((tmpvar_111 < t_hit_93) && (tmpvar_111 > 0.001))) {\n              t_hit_107 = tmpvar_111;\n              tmpvar_109 = bool(1);\n              tmpvar_108 = bool(0);\n            };\n            if (tmpvar_108) {\n              tmpvar_109 = bool(0);\n              tmpvar_108 = bool(0);\n            };\n            t_hit_93 = t_hit_107;\n            if (tmpvar_109) {\n              tmpvar_94 = bool(1);\n              break;\n            };\n            i_95++;\n          };\n          if (!(tmpvar_94)) {\n            tmpvar_94 = bool(1);\n          };\n        };\n        float tmpvar_112;\n        tmpvar_112 = abs((t_hit_93 - tmpvar_86));\n        if ((tmpvar_112 < 0.001)) {\n          vec3 I_113;\n          I_113 = -(tmpvar_88);\n          light_sum_74 = (light_sum_74 + (incidentIntensity_84 * (\n            (diffuseColor_66 * dot (N_65, tmpvar_88))\n           + \n            (specularColor_67 * pow (max (0.0, dot (\n              (I_113 - (2.0 * (dot (N_65, I_113) * N_65)))\n            , \n              -(V_64)\n            )), 128.0))\n          )));\n        } else {\n          inShade_71 = bool(1);\n        };\n      } else {\n        inShade_71 = bool(1);\n      };\n      areaShadowSamples_72++;\n      k_70++;\n    };\n    if ((tmpvar_80 && inShade_71)) {\n      highp int k_114;\n      areaShadowSamples_72 = shadowSamples;\n      light_sum_74 = vec3(0.0, 0.0, 0.0);\n      k_114 = 0;\n      while (true) {\n        vec3 incidentIntensity_115;\n        if ((k_114 >= areaShadowSamples_72)) {\n          break;\n        };\n        float sample_i_116;\n        sample_i_116 = float(k_114);\n        vec3 L_117;\n        float falloff_118;\n        float tmpvar_119;\n        tmpvar_119 = (1.0/(shadowDim));\n        randomIncrement += 0.02;\n        float tmpvar_120;\n        tmpvar_120 = ((lightSize_76.x * tmpvar_119) * ((float(mod (sample_i_116, shadowDim))) + fract(\n          (cos(dot ((P_63.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)\n        )));\n        randomIncrement += 0.02;\n        vec3 tmpvar_121;\n        tmpvar_121.x = ((lightPos_78.x - (lightSize_76.x * 0.5)) + tmpvar_120);\n        tmpvar_121.y = lightPos_78.y;\n        tmpvar_121.z = ((lightPos_78.z - (lightSize_76.y * 0.5)) + ((lightSize_76.y * tmpvar_119) * (\n          floor((sample_i_116 * tmpvar_119))\n         + \n          fract((cos(dot (\n            (P_63.yx + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n        )));\n        L_117 = (tmpvar_121 - P_63);\n        float tmpvar_122;\n        tmpvar_122 = sqrt(dot (L_117, L_117));\n        float tmpvar_123;\n        tmpvar_123 = (1.0/(((attenuationFactor.x * \n          (tmpvar_122 * tmpvar_122)\n        ) + (attenuationFactor.y * tmpvar_122))));\n        vec3 tmpvar_124;\n        tmpvar_124 = normalize(L_117);\n        L_117 = tmpvar_124;\n        falloff_118 = 1.0;\n        if ((lightSpot_75.x > 0.0)) {\n          float tmpvar_125;\n          if ((tmpvar_124.y > lightSpot_75.x)) {\n            tmpvar_125 = pow (tmpvar_124.y, lightSpot_75.y);\n          } else {\n            tmpvar_125 = 0.0;\n          };\n          falloff_118 = tmpvar_125;\n        };\n        incidentIntensity_115 = ((lightBrightness_77 * tmpvar_123) * falloff_118);\n        vec3 ray_origin_126;\n        ray_origin_126 = P_63;\n        vec3 ray_direction_127;\n        ray_direction_127 = tmpvar_124;\n        float t_hit_128;\n        t_hit_128 = tmpvar_122;\n        bool tmpvar_129;\n        bool tmpvar_130;\n        tmpvar_130 = bool(0);\n        highp int i_131;\n        highp int i_132;\n        i_132 = 0;\n        while (true) {\n          if ((i_132 >= numSpheres)) {\n            break;\n          };\n          float t_hit_133;\n          t_hit_133 = t_hit_128;\n          bool tmpvar_134;\n          vec3 tmpvar_135;\n          tmpvar_135 = (sphereCenters[i_132] - ray_origin_126);\n          float tmpvar_136;\n          tmpvar_136 = dot (tmpvar_135, ray_direction_127);\n          if ((tmpvar_136 < 0.0)) {\n            tmpvar_134 = bool(0);\n          } else {\n            float tmpvar_137;\n            tmpvar_137 = (dot (tmpvar_135, tmpvar_135) - (tmpvar_136 * tmpvar_136));\n            if ((tmpvar_137 > 0.64)) {\n              tmpvar_134 = bool(0);\n            } else {\n              float tmpvar_138;\n              tmpvar_138 = sqrt((0.64 - tmpvar_137));\n              float tmpvar_139;\n              tmpvar_139 = (tmpvar_136 - tmpvar_138);\n              float tmpvar_140;\n              tmpvar_140 = (tmpvar_136 + tmpvar_138);\n              float tmpvar_141;\n              if ((tmpvar_139 < 0.001)) {\n                tmpvar_141 = tmpvar_140;\n              } else {\n                tmpvar_141 = tmpvar_139;\n              };\n              if (((tmpvar_141 < t_hit_128) && (tmpvar_141 > 0.001))) {\n                t_hit_133 = tmpvar_141;\n                tmpvar_134 = bool(1);\n              } else {\n                tmpvar_134 = bool(0);\n              };\n            };\n          };\n          t_hit_128 = t_hit_133;\n          if (tmpvar_134) {\n            tmpvar_129 = bool(1);\n            tmpvar_130 = bool(1);\n            break;\n          };\n          i_132++;\n        };\n        if (!(tmpvar_130)) {\n          i_131 = 0;\n          while (true) {\n            if ((i_131 >= numPlanes)) {\n              break;\n            };\n            vec3 normal_142;\n            normal_142 = planeNormals[i_131];\n            float t_hit_143;\n            t_hit_143 = t_hit_128;\n            bool tmpvar_144;\n            tmpvar_144 = bool(1);\n            bool tmpvar_145;\n            vec3 tmpvar_146;\n            tmpvar_146 = (normal_142 * planeOffsets[i_131]);\n            float tmpvar_147;\n            tmpvar_147 = (((\n              (tmpvar_146.x + tmpvar_146.y)\n             + tmpvar_146.z) - dot (normal_142, ray_origin_126)) / dot (normal_142, ray_direction_127));\n            if (((tmpvar_147 < t_hit_128) && (tmpvar_147 > 0.001))) {\n              t_hit_143 = tmpvar_147;\n              tmpvar_145 = bool(1);\n              tmpvar_144 = bool(0);\n            };\n            if (tmpvar_144) {\n              tmpvar_145 = bool(0);\n              tmpvar_144 = bool(0);\n            };\n            t_hit_128 = t_hit_143;\n            if (tmpvar_145) {\n              tmpvar_129 = bool(1);\n              tmpvar_130 = bool(1);\n              break;\n            };\n            i_131++;\n          };\n          if (!(tmpvar_130)) {\n            tmpvar_129 = bool(0);\n            tmpvar_130 = bool(1);\n          };\n        };\n        if (!(tmpvar_129)) {\n          vec3 I_148;\n          I_148 = -(tmpvar_124);\n          light_sum_74 = (light_sum_74 + (incidentIntensity_115 * (\n            (diffuseColor_66 * dot (N_65, tmpvar_124))\n           + \n            (specularColor_67 * pow (max (0.0, dot (\n              (I_148 - (2.0 * (dot (N_65, I_148) * N_65)))\n            , \n              -(V_64)\n            )), 128.0))\n          )));\n        };\n        k_114++;\n      };\n    };\n    illuminationColor_69 = (illuminationColor_69 + (light_sum_74 / float(areaShadowSamples_72)));\n  };\n  pixelColor_5 = (pixelColor_5 + (roughness_15 * illuminationColor_69));\n  if ((((enableGI && \n    (diffuseColor_12.x > 0.0)\n  ) && (diffuseColor_12.y > 0.0)) && (diffuseColor_12.z > 0.0))) {\n    if ((roughness_15 < 1.0)) {\n      vec3 P_149;\n      P_149 = position_10;\n      vec3 V_150;\n      V_150 = tmpvar_6;\n      vec3 N_151;\n      N_151 = normal_11;\n      float G1_alpha_153;\n      float VNDF_alpha_154;\n      mat3 basis_155;\n      vec3 indirect_sampling_sum_156;\n      mat3 ret_157;\n      ret_157[1] = normal_11;\n      if ((normal_11.z < -0.9998057)) {\n        ret_157[0] = vec3(0.0, -1.0, 0.0);\n        ret_157[2] = vec3(-1.0, 0.0, 0.0);\n      } else {\n        float tmpvar_158;\n        tmpvar_158 = (1.0/((1.0 + normal_11.z)));\n        float tmpvar_159;\n        tmpvar_159 = ((-(normal_11.x) * normal_11.y) * tmpvar_158);\n        vec3 tmpvar_160;\n        tmpvar_160.x = (1.0 - ((normal_11.x * normal_11.x) * tmpvar_158));\n        tmpvar_160.y = tmpvar_159;\n        tmpvar_160.z = -(normal_11.x);\n        ret_157[0] = tmpvar_160;\n        vec3 tmpvar_161;\n        tmpvar_161.x = tmpvar_159;\n        tmpvar_161.y = (1.0 - ((normal_11.y * normal_11.y) * tmpvar_158));\n        tmpvar_161.z = -(normal_11.y);\n        ret_157[2] = tmpvar_161;\n      };\n      basis_155 = ret_157;\n      VNDF_alpha_154 = (roughness_15 * roughness_15);\n      float tmpvar_162;\n      tmpvar_162 = max (roughness_15, 0.02);\n      float tmpvar_163;\n      tmpvar_163 = (tmpvar_162 * tmpvar_162);\n      G1_alpha_153 = (tmpvar_163 * tmpvar_163);\n      for (highp int i_152 = 0; i_152 < indirectSamples; i_152++) {\n        float roughness2_164;\n        vec3 reflective2_165;\n        vec3 specular2_166;\n        vec3 diffuse2_167;\n        float G1_NoR_168;\n        randomIncrement += 0.02;\n        float tmpvar_169;\n        tmpvar_169 = fract((cos(\n          dot ((P_149.xz + randomIncrement), vec2(23.14069, 2.665144))\n        ) * 12345.68));\n        randomIncrement += 0.02;\n        float tmpvar_170;\n        tmpvar_170 = fract((cos(\n          dot ((P_149.xy + randomIncrement), vec2(23.14069, 2.665144))\n        ) * 12345.68));\n        float t2_171;\n        vec3 tmpvar_172;\n        tmpvar_172.x = dot (V_150, basis_155[0]);\n        tmpvar_172.y = dot (V_150, basis_155[2]);\n        tmpvar_172.z = dot (V_150, basis_155[1]);\n        vec3 tmpvar_173;\n        tmpvar_173 = -(tmpvar_172);\n        vec3 tmpvar_174;\n        tmpvar_174.xy = (vec2(VNDF_alpha_154) * tmpvar_173.xy);\n        tmpvar_174.z = tmpvar_173.z;\n        vec3 tmpvar_175;\n        tmpvar_175 = normalize(tmpvar_174);\n        float tmpvar_176;\n        tmpvar_176 = ((tmpvar_175.x * tmpvar_175.x) + (tmpvar_175.y * tmpvar_175.y));\n        vec3 tmpvar_177;\n        if ((tmpvar_176 > 0.0)) {\n          vec3 tmpvar_178;\n          tmpvar_178.z = 0.0;\n          tmpvar_178.x = -(tmpvar_175.y);\n          tmpvar_178.y = tmpvar_175.x;\n          tmpvar_177 = (tmpvar_178 * inversesqrt(tmpvar_176));\n        } else {\n          tmpvar_177 = vec3(1.0, 0.0, 0.0);\n        };\n        float tmpvar_179;\n        tmpvar_179 = sqrt(tmpvar_169);\n        float tmpvar_180;\n        tmpvar_180 = (6.283186 * tmpvar_170);\n        float tmpvar_181;\n        tmpvar_181 = (tmpvar_179 * cos(tmpvar_180));\n        float tmpvar_182;\n        tmpvar_182 = (0.5 * (1.0 + tmpvar_175.z));\n        t2_171 = (((1.0 - tmpvar_182) * sqrt(\n          (1.0 - (tmpvar_181 * tmpvar_181))\n        )) + (tmpvar_182 * (tmpvar_179 * \n          sin(tmpvar_180)\n        )));\n        vec3 tmpvar_183;\n        tmpvar_183 = (((tmpvar_181 * tmpvar_177) + (t2_171 * \n          ((tmpvar_175.yzx * tmpvar_177.zxy) - (tmpvar_175.zxy * tmpvar_177.yzx))\n        )) + (sqrt(\n          max (0.0, ((1.0 - (tmpvar_181 * tmpvar_181)) - (t2_171 * t2_171)))\n        ) * tmpvar_175));\n        vec3 tmpvar_184;\n        tmpvar_184.x = (VNDF_alpha_154 * tmpvar_183.x);\n        tmpvar_184.y = max (0.0, tmpvar_183.z);\n        tmpvar_184.z = (VNDF_alpha_154 * tmpvar_183.y);\n        vec3 tmpvar_185;\n        tmpvar_185 = normalize((basis_155 * tmpvar_184));\n        vec3 tmpvar_186;\n        tmpvar_186 = (V_150 - (2.0 * (\n          dot (tmpvar_185, V_150)\n         * tmpvar_185)));\n        float tmpvar_187;\n        tmpvar_187 = max (0.0, dot (N_151, tmpvar_186));\n        G1_NoR_168 = ((2.0 * tmpvar_187) / (tmpvar_187 + sqrt(\n          (G1_alpha_153 + ((1.0 - G1_alpha_153) * (tmpvar_187 * tmpvar_187)))\n        )));\n        vec3 tmpvar_188;\n        tmpvar_188 = normalize(tmpvar_186);\n        vec3 ray_origin_189;\n        ray_origin_189 = P_149;\n        vec3 ray_direction_190;\n        ray_direction_190 = tmpvar_188;\n        float t_hit_191;\n        t_hit_191 = 20.0;\n        vec3 position_192;\n        vec3 normal_193;\n        vec3 diffuseColor_194;\n        diffuseColor_194 = diffuse2_167;\n        vec3 specularColor_195;\n        specularColor_195 = specular2_166;\n        vec3 reflectiveColor_196;\n        reflectiveColor_196 = reflective2_165;\n        float roughness_197;\n        roughness_197 = roughness2_164;\n        bool intersectLight_198;\n        intersectLight_198 = bool(1);\n        highp int idx_201;\n        highp int intersected_202;\n        intersected_202 = 0;\n        idx_201 = 0;\n        for (highp int i_200 = 0; i_200 < numSpheres; i_200++) {\n          float t_hit_203;\n          t_hit_203 = t_hit_191;\n          bool tmpvar_204;\n          vec3 tmpvar_205;\n          tmpvar_205 = (sphereCenters[i_200] - ray_origin_189);\n          float tmpvar_206;\n          tmpvar_206 = dot (tmpvar_205, ray_direction_190);\n          if ((tmpvar_206 < 0.0)) {\n            tmpvar_204 = bool(0);\n          } else {\n            float tmpvar_207;\n            tmpvar_207 = (dot (tmpvar_205, tmpvar_205) - (tmpvar_206 * tmpvar_206));\n            if ((tmpvar_207 > 0.64)) {\n              tmpvar_204 = bool(0);\n            } else {\n              float tmpvar_208;\n              tmpvar_208 = sqrt((0.64 - tmpvar_207));\n              float tmpvar_209;\n              tmpvar_209 = (tmpvar_206 - tmpvar_208);\n              float tmpvar_210;\n              tmpvar_210 = (tmpvar_206 + tmpvar_208);\n              float tmpvar_211;\n              if ((tmpvar_209 < 0.01)) {\n                tmpvar_211 = tmpvar_210;\n              } else {\n                tmpvar_211 = tmpvar_209;\n              };\n              if (((tmpvar_211 < t_hit_191) && (tmpvar_211 > 0.01))) {\n                t_hit_203 = tmpvar_211;\n                tmpvar_204 = bool(1);\n              } else {\n                tmpvar_204 = bool(0);\n              };\n            };\n          };\n          t_hit_191 = t_hit_203;\n          if (tmpvar_204) {\n            idx_201 = i_200;\n            intersected_202 = 1;\n          };\n        };\n        for (highp int i_199 = 0; i_199 < numPlanes; i_199++) {\n          vec3 tmpvar_212;\n          tmpvar_212 = planeNormals[i_199];\n          bool tmpvar_213;\n          if (enablePlaneBacksides) {\n            tmpvar_213 = bool(1);\n          } else {\n            tmpvar_213 = (dot (ray_direction_190, tmpvar_212) < 0.0);\n          };\n          if (tmpvar_213) {\n            float t_hit_214;\n            t_hit_214 = t_hit_191;\n            bool tmpvar_215;\n            tmpvar_215 = bool(1);\n            bool tmpvar_216;\n            vec3 tmpvar_217;\n            tmpvar_217 = (tmpvar_212 * planeOffsets[i_199]);\n            float tmpvar_218;\n            tmpvar_218 = (((\n              (tmpvar_217.x + tmpvar_217.y)\n             + tmpvar_217.z) - dot (tmpvar_212, ray_origin_189)) / dot (tmpvar_212, ray_direction_190));\n            if (((tmpvar_218 < t_hit_191) && (tmpvar_218 > 0.01))) {\n              t_hit_214 = tmpvar_218;\n              tmpvar_216 = bool(1);\n              tmpvar_215 = bool(0);\n            };\n            if (tmpvar_215) {\n              tmpvar_216 = bool(0);\n              tmpvar_215 = bool(0);\n            };\n            t_hit_191 = t_hit_214;\n            if (tmpvar_216) {\n              normal_193 = tmpvar_212;\n              idx_201 = i_199;\n              intersected_202 = 2;\n            };\n          };\n        };\n        intersectLight_198 = bool(0);\n        for (highp int i_219 = 0; i_219 < numLights; i_219++) {\n          bool tmp_220;\n          vec3 tmpvar_221;\n          tmpvar_221 = lightPos[i_219];\n          vec2 tmpvar_222;\n          tmpvar_222 = lightSize[i_219];\n          tmp_220 = bool(0);\n          if (((tmpvar_222.x > 0.0) && (tmpvar_222.y > 0.0))) {\n            float t_hit_223;\n            t_hit_223 = t_hit_191;\n            bool tmpvar_224;\n            tmpvar_224 = bool(1);\n            bool tmpvar_225;\n            vec3 tmpvar_226;\n            tmpvar_226 = (vec3(0.0, 1.0, 0.0) * tmpvar_221.y);\n            float tmpvar_227;\n            tmpvar_227 = (((\n              (tmpvar_226.x + tmpvar_226.y)\n             + tmpvar_226.z) - ray_origin_189.y) / ray_direction_190.y);\n            if (((tmpvar_227 < t_hit_191) && (tmpvar_227 > 0.01))) {\n              vec3 tmpvar_228;\n              tmpvar_228 = (ray_origin_189 + (ray_direction_190 * tmpvar_227));\n              if ((((tmpvar_222.x + tmpvar_222.y) == 0.0) || ((\n                ((tmpvar_228.x < (tmpvar_221.x + (tmpvar_222.x * 0.5))) && (tmpvar_228.x > (tmpvar_221.x - (tmpvar_222.x * 0.5))))\n               && \n                (tmpvar_228.z < (tmpvar_221.z + (tmpvar_222.y * 0.5)))\n              ) && (tmpvar_228.z > \n                (tmpvar_221.z - (tmpvar_222.y * 0.5))\n              )))) {\n                t_hit_223 = tmpvar_227;\n                tmpvar_225 = bool(1);\n                tmpvar_224 = bool(0);\n              };\n            };\n            if (tmpvar_224) {\n              tmpvar_225 = bool(0);\n              tmpvar_224 = bool(0);\n            };\n            t_hit_191 = t_hit_223;\n            tmp_220 = tmpvar_225;\n          } else {\n            float t_hit_229;\n            t_hit_229 = t_hit_191;\n            bool tmpvar_230;\n            vec3 tmpvar_231;\n            tmpvar_231 = (tmpvar_221 - ray_origin_189);\n            float tmpvar_232;\n            tmpvar_232 = dot (tmpvar_231, ray_direction_190);\n            if ((tmpvar_232 < 0.0)) {\n              tmpvar_230 = bool(0);\n            } else {\n              float tmpvar_233;\n              tmpvar_233 = (dot (tmpvar_231, tmpvar_231) - (tmpvar_232 * tmpvar_232));\n              if ((tmpvar_233 > 0.01)) {\n                tmpvar_230 = bool(0);\n              } else {\n                float tmpvar_234;\n                tmpvar_234 = sqrt((0.01 - tmpvar_233));\n                float tmpvar_235;\n                tmpvar_235 = (tmpvar_232 - tmpvar_234);\n                float tmpvar_236;\n                tmpvar_236 = (tmpvar_232 + tmpvar_234);\n                float tmpvar_237;\n                if ((tmpvar_235 < 0.01)) {\n                  tmpvar_237 = tmpvar_236;\n                } else {\n                  tmpvar_237 = tmpvar_235;\n                };\n                if (((tmpvar_237 < t_hit_191) && (tmpvar_237 > 0.01))) {\n                  t_hit_229 = tmpvar_237;\n                  tmpvar_230 = bool(1);\n                } else {\n                  tmpvar_230 = bool(0);\n                };\n              };\n            };\n            t_hit_191 = t_hit_229;\n            tmp_220 = tmpvar_230;\n          };\n          if (tmp_220) {\n            idx_201 = i_219;\n            intersected_202 = 3;\n          };\n        };\n        position_192 = (P_149 + (tmpvar_188 * t_hit_191));\n        if ((intersected_202 == 1)) {\n          diffuseColor_194 = sphereColors[idx_201];\n          specularColor_195 = sphereSpecColors[idx_201];\n          reflectiveColor_196 = reflectiveColors[idx_201];\n          roughness_197 = sphereRoughness[idx_201];\n          vec3 tmpvar_238;\n          tmpvar_238 = normalize((position_192 - sphereCenters[idx_201]));\n          normal_193 = tmpvar_238;\n          float tmpvar_239;\n          tmpvar_239 = dot (tmpvar_238, -(tmpvar_188));\n          if ((tmpvar_239 < 0.0)) {\n            normal_193 = -(tmpvar_238);\n          };\n        } else {\n          if ((intersected_202 == 2)) {\n            if (!(enablePlaneMirrors)) {\n              diffuseColor_194 = planeColors[idx_201];\n              specularColor_195 = vec3(planeSpecular[idx_201]);\n              reflectiveColor_196 = vec3(0.0, 0.0, 0.0);\n              roughness_197 = planeRoughness[idx_201];\n            } else {\n              diffuseColor_194 = (planeColors[idx_201] * 0.01);\n              specularColor_195 = vec3(0.0, 0.0, 0.0);\n              reflectiveColor_196 = planeColors[idx_201];\n              roughness_197 = 1.0;\n            };\n            float tmpvar_240;\n            tmpvar_240 = dot (normal_193, -(tmpvar_188));\n            if ((tmpvar_240 < 0.0)) {\n              normal_193 = -(normal_193);\n            };\n          } else {\n            if ((intersected_202 == 3)) {\n              float spot_falloff_241;\n              spot_falloff_241 = 1.0;\n              vec2 tmpvar_242;\n              tmpvar_242 = lightSpot[idx_201];\n              if ((tmpvar_242.x > 0.0)) {\n                float tmpvar_243;\n                if ((tmpvar_188.y > tmpvar_242.x)) {\n                  tmpvar_243 = pow (tmpvar_188.y, tmpvar_242.y);\n                } else {\n                  tmpvar_243 = 0.0;\n                };\n                spot_falloff_241 = tmpvar_243;\n              };\n              diffuseColor_194 = ((spot_falloff_241 * lightBrightness[idx_201]) * 0.2);\n              intersectLight_198 = bool(1);\n            };\n          };\n        };\n        diffuse2_167 = diffuseColor_194;\n        specular2_166 = specularColor_195;\n        reflective2_165 = reflectiveColor_196;\n        roughness2_164 = roughness_197;\n        vec3 tmpvar_244;\n        if (intersectLight_198) {\n          tmpvar_244 = diffuseColor_194;\n        } else {\n          vec3 P_245;\n          P_245 = position_192;\n          vec3 N_246;\n          N_246 = normal_193;\n          vec3 diffuseColor_247;\n          diffuseColor_247 = (diffuseColor_194 + reflectiveColor_196);\n          highp int i_248;\n          vec3 illuminationColor_249;\n          i_248 = 0;\n          while (true) {\n            float spotAttenuation_250;\n            if ((i_248 >= numLights)) {\n              break;\n            };\n            vec3 tmpvar_251;\n            tmpvar_251 = (lightPos[i_248] - P_245);\n            float tmpvar_252;\n            tmpvar_252 = sqrt(dot (tmpvar_251, tmpvar_251));\n            vec3 tmpvar_253;\n            tmpvar_253 = normalize(tmpvar_251);\n            vec2 tmpvar_254;\n            tmpvar_254 = lightSpot[i_248];\n            spotAttenuation_250 = 1.0;\n            if ((tmpvar_254.x > 0.0)) {\n              float tmpvar_255;\n              if ((tmpvar_253.y > tmpvar_254.x)) {\n                tmpvar_255 = pow (tmpvar_253.y, tmpvar_254.y);\n              } else {\n                tmpvar_255 = 0.0;\n              };\n              spotAttenuation_250 = tmpvar_255;\n            };\n            if ((spotAttenuation_250 > 0.0)) {\n              vec3 lightBrightness_256;\n              lightBrightness_256 = lightBrightness[i_248];\n              float tmpvar_257;\n              tmpvar_257 = (1.0/(((attenuationFactor.x * \n                (tmpvar_252 * tmpvar_252)\n              ) + (attenuationFactor.y * tmpvar_252))));\n              if ((tmpvar_257 > 0.004)) {\n                float tmpvar_258;\n                tmpvar_258 = dot (N_246, tmpvar_253);\n                if ((tmpvar_258 > 0.0)) {\n                  vec3 ray_origin_259;\n                  ray_origin_259 = P_245;\n                  vec3 ray_direction_260;\n                  ray_direction_260 = tmpvar_253;\n                  float t_hit_261;\n                  t_hit_261 = tmpvar_252;\n                  bool tmpvar_262;\n                  bool tmpvar_263;\n                  tmpvar_263 = bool(0);\n                  highp int i_264;\n                  highp int i_265;\n                  i_265 = 0;\n                  while (true) {\n                    if ((i_265 >= numSpheres)) {\n                      break;\n                    };\n                    float t_hit_266;\n                    t_hit_266 = t_hit_261;\n                    bool tmpvar_267;\n                    vec3 tmpvar_268;\n                    tmpvar_268 = (sphereCenters[i_265] - ray_origin_259);\n                    float tmpvar_269;\n                    tmpvar_269 = dot (tmpvar_268, ray_direction_260);\n                    if ((tmpvar_269 < 0.0)) {\n                      tmpvar_267 = bool(0);\n                    } else {\n                      float tmpvar_270;\n                      tmpvar_270 = (dot (tmpvar_268, tmpvar_268) - (tmpvar_269 * tmpvar_269));\n                      if ((tmpvar_270 > 0.64)) {\n                        tmpvar_267 = bool(0);\n                      } else {\n                        float tmpvar_271;\n                        tmpvar_271 = sqrt((0.64 - tmpvar_270));\n                        float tmpvar_272;\n                        tmpvar_272 = (tmpvar_269 - tmpvar_271);\n                        float tmpvar_273;\n                        tmpvar_273 = (tmpvar_269 + tmpvar_271);\n                        float tmpvar_274;\n                        if ((tmpvar_272 < 0.001)) {\n                          tmpvar_274 = tmpvar_273;\n                        } else {\n                          tmpvar_274 = tmpvar_272;\n                        };\n                        if (((tmpvar_274 < t_hit_261) && (tmpvar_274 > 0.001))) {\n                          t_hit_266 = tmpvar_274;\n                          tmpvar_267 = bool(1);\n                        } else {\n                          tmpvar_267 = bool(0);\n                        };\n                      };\n                    };\n                    t_hit_261 = t_hit_266;\n                    if (tmpvar_267) {\n                      tmpvar_262 = bool(1);\n                      tmpvar_263 = bool(1);\n                      break;\n                    };\n                    i_265++;\n                  };\n                  if (!(tmpvar_263)) {\n                    i_264 = 0;\n                    while (true) {\n                      if ((i_264 >= numPlanes)) {\n                        break;\n                      };\n                      vec3 normal_275;\n                      normal_275 = planeNormals[i_264];\n                      float t_hit_276;\n                      t_hit_276 = t_hit_261;\n                      bool tmpvar_277;\n                      tmpvar_277 = bool(1);\n                      bool tmpvar_278;\n                      vec3 tmpvar_279;\n                      tmpvar_279 = (normal_275 * planeOffsets[i_264]);\n                      float tmpvar_280;\n                      tmpvar_280 = (((\n                        (tmpvar_279.x + tmpvar_279.y)\n                       + tmpvar_279.z) - dot (normal_275, ray_origin_259)) / dot (normal_275, ray_direction_260));\n                      if (((tmpvar_280 < t_hit_261) && (tmpvar_280 > 0.001))) {\n                        t_hit_276 = tmpvar_280;\n                        tmpvar_278 = bool(1);\n                        tmpvar_277 = bool(0);\n                      };\n                      if (tmpvar_277) {\n                        tmpvar_278 = bool(0);\n                        tmpvar_277 = bool(0);\n                      };\n                      t_hit_261 = t_hit_276;\n                      if (tmpvar_278) {\n                        tmpvar_262 = bool(1);\n                        tmpvar_263 = bool(1);\n                        break;\n                      };\n                      i_264++;\n                    };\n                    if (!(tmpvar_263)) {\n                      tmpvar_262 = bool(0);\n                      tmpvar_263 = bool(1);\n                    };\n                  };\n                  if (!(tmpvar_262)) {\n                    illuminationColor_249 = (illuminationColor_249 + ((diffuseColor_247 * lightBrightness_256) * (\n                      (tmpvar_257 * spotAttenuation_250)\n                     * tmpvar_258)));\n                  };\n                };\n              };\n            };\n            i_248++;\n          };\n          tmpvar_244 = (G1_NoR_168 * illuminationColor_249);\n        };\n        indirect_sampling_sum_156 = (indirect_sampling_sum_156 + tmpvar_244);\n      };\n      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_156 / \n        float(indirectSamples)\n      ) * diffuseColor_12));\n    } else {\n      vec3 P_281;\n      P_281 = position_10;\n      vec3 N_282;\n      N_282 = normal_11;\n      vec3 indirect_sampling_sum_284;\n      for (highp int i_283 = 0; i_283 < indirectSamples; i_283++) {\n        float roughness2_285;\n        vec3 reflective2_286;\n        vec3 specular2_287;\n        vec3 diffuse2_288;\n        float sampleIdx_289;\n        sampleIdx_289 = float(i_283);\n        randomIncrement += 0.02;\n        float tmpvar_290;\n        tmpvar_290 = ((1.0 - (\n          (sampleIdx_289 / float((indirectSamples - 1)))\n         * 2.0)) + ((\n          fract((cos(dot (\n            (P_281.xy + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n         * 0.4) - 0.2));\n        float tmpvar_291;\n        tmpvar_291 = sqrt((1.0 - (tmpvar_290 * tmpvar_290)));\n        randomIncrement += 0.02;\n        float tmpvar_292;\n        tmpvar_292 = ((2.399963 * sampleIdx_289) + ((\n          fract((cos(dot (\n            (P_281.xy + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n         * 0.5) - 0.25));\n        vec3 tmpvar_293;\n        tmpvar_293.x = (cos(tmpvar_292) * tmpvar_291);\n        tmpvar_293.y = tmpvar_290;\n        tmpvar_293.z = (sin(tmpvar_292) * tmpvar_291);\n        vec3 ray_origin_294;\n        ray_origin_294 = P_281;\n        vec3 ray_direction_295;\n        ray_direction_295 = normalize(normalize((N_282 + tmpvar_293)));\n        float t_hit_296;\n        t_hit_296 = 10.0;\n        vec3 position_297;\n        vec3 normal_298;\n        vec3 diffuseColor_299;\n        diffuseColor_299 = diffuse2_288;\n        vec3 specularColor_300;\n        specularColor_300 = specular2_287;\n        vec3 reflectiveColor_301;\n        reflectiveColor_301 = reflective2_286;\n        float roughness_302;\n        roughness_302 = roughness2_285;\n        highp int idx_305;\n        highp int intersected_306;\n        intersected_306 = 0;\n        idx_305 = 0;\n        for (highp int i_304 = 0; i_304 < numSpheres; i_304++) {\n          float t_hit_307;\n          t_hit_307 = t_hit_296;\n          bool tmpvar_308;\n          vec3 tmpvar_309;\n          tmpvar_309 = (sphereCenters[i_304] - ray_origin_294);\n          float tmpvar_310;\n          tmpvar_310 = dot (tmpvar_309, ray_direction_295);\n          if ((tmpvar_310 < 0.0)) {\n            tmpvar_308 = bool(0);\n          } else {\n            float tmpvar_311;\n            tmpvar_311 = (dot (tmpvar_309, tmpvar_309) - (tmpvar_310 * tmpvar_310));\n            if ((tmpvar_311 > 0.64)) {\n              tmpvar_308 = bool(0);\n            } else {\n              float tmpvar_312;\n              tmpvar_312 = sqrt((0.64 - tmpvar_311));\n              float tmpvar_313;\n              tmpvar_313 = (tmpvar_310 - tmpvar_312);\n              float tmpvar_314;\n              tmpvar_314 = (tmpvar_310 + tmpvar_312);\n              float tmpvar_315;\n              if ((tmpvar_313 < 0.01)) {\n                tmpvar_315 = tmpvar_314;\n              } else {\n                tmpvar_315 = tmpvar_313;\n              };\n              if (((tmpvar_315 < t_hit_296) && (tmpvar_315 > 0.01))) {\n                t_hit_307 = tmpvar_315;\n                tmpvar_308 = bool(1);\n              } else {\n                tmpvar_308 = bool(0);\n              };\n            };\n          };\n          t_hit_296 = t_hit_307;\n          if (tmpvar_308) {\n            idx_305 = i_304;\n            intersected_306 = 1;\n          };\n        };\n        for (highp int i_303 = 0; i_303 < numPlanes; i_303++) {\n          vec3 tmpvar_316;\n          tmpvar_316 = planeNormals[i_303];\n          bool tmpvar_317;\n          if (enablePlaneBacksides) {\n            tmpvar_317 = bool(1);\n          } else {\n            tmpvar_317 = (dot (ray_direction_295, tmpvar_316) < 0.0);\n          };\n          if (tmpvar_317) {\n            float t_hit_318;\n            t_hit_318 = t_hit_296;\n            bool tmpvar_319;\n            tmpvar_319 = bool(1);\n            bool tmpvar_320;\n            vec3 tmpvar_321;\n            tmpvar_321 = (tmpvar_316 * planeOffsets[i_303]);\n            float tmpvar_322;\n            tmpvar_322 = (((\n              (tmpvar_321.x + tmpvar_321.y)\n             + tmpvar_321.z) - dot (tmpvar_316, ray_origin_294)) / dot (tmpvar_316, ray_direction_295));\n            if (((tmpvar_322 < t_hit_296) && (tmpvar_322 > 0.01))) {\n              t_hit_318 = tmpvar_322;\n              tmpvar_320 = bool(1);\n              tmpvar_319 = bool(0);\n            };\n            if (tmpvar_319) {\n              tmpvar_320 = bool(0);\n              tmpvar_319 = bool(0);\n            };\n            t_hit_296 = t_hit_318;\n            if (tmpvar_320) {\n              normal_298 = tmpvar_316;\n              idx_305 = i_303;\n              intersected_306 = 2;\n            };\n          };\n        };\n        position_297 = (P_281 + (ray_direction_295 * t_hit_296));\n        if ((intersected_306 == 1)) {\n          diffuseColor_299 = sphereColors[idx_305];\n          specularColor_300 = sphereSpecColors[idx_305];\n          reflectiveColor_301 = reflectiveColors[idx_305];\n          roughness_302 = sphereRoughness[idx_305];\n          vec3 tmpvar_323;\n          tmpvar_323 = normalize((position_297 - sphereCenters[idx_305]));\n          normal_298 = tmpvar_323;\n          float tmpvar_324;\n          tmpvar_324 = dot (tmpvar_323, -(ray_direction_295));\n          if ((tmpvar_324 < 0.0)) {\n            normal_298 = -(tmpvar_323);\n          };\n        } else {\n          if ((intersected_306 == 2)) {\n            if (!(enablePlaneMirrors)) {\n              diffuseColor_299 = planeColors[idx_305];\n              specularColor_300 = vec3(planeSpecular[idx_305]);\n              reflectiveColor_301 = vec3(0.0, 0.0, 0.0);\n              roughness_302 = planeRoughness[idx_305];\n            } else {\n              diffuseColor_299 = (planeColors[idx_305] * 0.01);\n              specularColor_300 = vec3(0.0, 0.0, 0.0);\n              reflectiveColor_301 = planeColors[idx_305];\n              roughness_302 = 1.0;\n            };\n            float tmpvar_325;\n            tmpvar_325 = dot (normal_298, -(ray_direction_295));\n            if ((tmpvar_325 < 0.0)) {\n              normal_298 = -(normal_298);\n            };\n          } else {\n            if ((intersected_306 == 3)) {\n              float spot_falloff_326;\n              spot_falloff_326 = 1.0;\n              vec2 tmpvar_327;\n              tmpvar_327 = lightSpot[idx_305];\n              if ((tmpvar_327.x > 0.0)) {\n                float tmpvar_328;\n                if ((ray_direction_295.y > tmpvar_327.x)) {\n                  tmpvar_328 = pow (ray_direction_295.y, tmpvar_327.y);\n                } else {\n                  tmpvar_328 = 0.0;\n                };\n                spot_falloff_326 = tmpvar_328;\n              };\n              diffuseColor_299 = ((spot_falloff_326 * lightBrightness[idx_305]) * 0.2);\n            };\n          };\n        };\n        diffuse2_288 = diffuseColor_299;\n        specular2_287 = specularColor_300;\n        reflective2_286 = reflectiveColor_301;\n        roughness2_285 = roughness_302;\n        vec3 P_329;\n        P_329 = position_297;\n        vec3 N_330;\n        N_330 = normal_298;\n        vec3 diffuseColor_331;\n        diffuseColor_331 = (diffuseColor_299 + reflectiveColor_301);\n        vec3 illuminationColor_333;\n        for (highp int i_332 = 0; i_332 < numLights; i_332++) {\n          float spotAttenuation_334;\n          vec3 tmpvar_335;\n          tmpvar_335 = (lightPos[i_332] - P_329);\n          float tmpvar_336;\n          tmpvar_336 = sqrt(dot (tmpvar_335, tmpvar_335));\n          vec3 tmpvar_337;\n          tmpvar_337 = normalize(tmpvar_335);\n          vec2 tmpvar_338;\n          tmpvar_338 = lightSpot[i_332];\n          spotAttenuation_334 = 1.0;\n          if ((tmpvar_338.x > 0.0)) {\n            float tmpvar_339;\n            if ((tmpvar_337.y > tmpvar_338.x)) {\n              tmpvar_339 = pow (tmpvar_337.y, tmpvar_338.y);\n            } else {\n              tmpvar_339 = 0.0;\n            };\n            spotAttenuation_334 = tmpvar_339;\n          };\n          if ((spotAttenuation_334 > 0.0)) {\n            vec3 lightBrightness_340;\n            lightBrightness_340 = lightBrightness[i_332];\n            float tmpvar_341;\n            tmpvar_341 = (1.0/(((attenuationFactor.x * \n              (tmpvar_336 * tmpvar_336)\n            ) + (attenuationFactor.y * tmpvar_336))));\n            if ((tmpvar_341 > 0.004)) {\n              float tmpvar_342;\n              tmpvar_342 = dot (N_330, tmpvar_337);\n              if ((tmpvar_342 > 0.0)) {\n                vec3 ray_origin_343;\n                ray_origin_343 = P_329;\n                vec3 ray_direction_344;\n                ray_direction_344 = tmpvar_337;\n                float t_hit_345;\n                t_hit_345 = tmpvar_336;\n                bool tmpvar_346;\n                bool tmpvar_347;\n                tmpvar_347 = bool(0);\n                highp int i_348;\n                highp int i_349;\n                i_349 = 0;\n                while (true) {\n                  if ((i_349 >= numSpheres)) {\n                    break;\n                  };\n                  float t_hit_350;\n                  t_hit_350 = t_hit_345;\n                  bool tmpvar_351;\n                  vec3 tmpvar_352;\n                  tmpvar_352 = (sphereCenters[i_349] - ray_origin_343);\n                  float tmpvar_353;\n                  tmpvar_353 = dot (tmpvar_352, ray_direction_344);\n                  if ((tmpvar_353 < 0.0)) {\n                    tmpvar_351 = bool(0);\n                  } else {\n                    float tmpvar_354;\n                    tmpvar_354 = (dot (tmpvar_352, tmpvar_352) - (tmpvar_353 * tmpvar_353));\n                    if ((tmpvar_354 > 0.64)) {\n                      tmpvar_351 = bool(0);\n                    } else {\n                      float tmpvar_355;\n                      tmpvar_355 = sqrt((0.64 - tmpvar_354));\n                      float tmpvar_356;\n                      tmpvar_356 = (tmpvar_353 - tmpvar_355);\n                      float tmpvar_357;\n                      tmpvar_357 = (tmpvar_353 + tmpvar_355);\n                      float tmpvar_358;\n                      if ((tmpvar_356 < 0.001)) {\n                        tmpvar_358 = tmpvar_357;\n                      } else {\n                        tmpvar_358 = tmpvar_356;\n                      };\n                      if (((tmpvar_358 < t_hit_345) && (tmpvar_358 > 0.001))) {\n                        t_hit_350 = tmpvar_358;\n                        tmpvar_351 = bool(1);\n                      } else {\n                        tmpvar_351 = bool(0);\n                      };\n                    };\n                  };\n                  t_hit_345 = t_hit_350;\n                  if (tmpvar_351) {\n                    tmpvar_346 = bool(1);\n                    tmpvar_347 = bool(1);\n                    break;\n                  };\n                  i_349++;\n                };\n                if (!(tmpvar_347)) {\n                  i_348 = 0;\n                  while (true) {\n                    if ((i_348 >= numPlanes)) {\n                      break;\n                    };\n                    vec3 normal_359;\n                    normal_359 = planeNormals[i_348];\n                    float t_hit_360;\n                    t_hit_360 = t_hit_345;\n                    bool tmpvar_361;\n                    tmpvar_361 = bool(1);\n                    bool tmpvar_362;\n                    vec3 tmpvar_363;\n                    tmpvar_363 = (normal_359 * planeOffsets[i_348]);\n                    float tmpvar_364;\n                    tmpvar_364 = (((\n                      (tmpvar_363.x + tmpvar_363.y)\n                     + tmpvar_363.z) - dot (normal_359, ray_origin_343)) / dot (normal_359, ray_direction_344));\n                    if (((tmpvar_364 < t_hit_345) && (tmpvar_364 > 0.001))) {\n                      t_hit_360 = tmpvar_364;\n                      tmpvar_362 = bool(1);\n                      tmpvar_361 = bool(0);\n                    };\n                    if (tmpvar_361) {\n                      tmpvar_362 = bool(0);\n                      tmpvar_361 = bool(0);\n                    };\n                    t_hit_345 = t_hit_360;\n                    if (tmpvar_362) {\n                      tmpvar_346 = bool(1);\n                      tmpvar_347 = bool(1);\n                      break;\n                    };\n                    i_348++;\n                  };\n                  if (!(tmpvar_347)) {\n                    tmpvar_346 = bool(0);\n                    tmpvar_347 = bool(1);\n                  };\n                };\n                if (!(tmpvar_346)) {\n                  illuminationColor_333 = (illuminationColor_333 + ((diffuseColor_331 * lightBrightness_340) * (\n                    (tmpvar_341 * spotAttenuation_334)\n                   * tmpvar_342)));\n                };\n              };\n            };\n          };\n        };\n        indirect_sampling_sum_284 = (indirect_sampling_sum_284 + illuminationColor_333);\n      };\n      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_284 / \n        float(indirectSamples)\n      ) * diffuseColor_12));\n    };\n  };\n  bool tmpvar_365;\n  if ((rayBounces > 0)) {\n    tmpvar_365 = (sqrt(dot (reflectiveColor_14, reflectiveColor_14)) > 0.0);\n  } else {\n    tmpvar_365 = bool(0);\n  };\n  if (tmpvar_365) {\n    vec3 P_366;\n    P_366 = position_10;\n    vec3 V_367;\n    V_367 = tmpvar_6;\n    vec3 N_368;\n    N_368 = normal_11;\n    vec3 reflectiveColor_369;\n    reflectiveColor_369 = reflectiveColor_14;\n    highp int i_370;\n    vec3 reflectionSum_371;\n    i_370 = 0;\n    while (true) {\n      vec3 mirror_sample_color_372;\n      float roughness2_373;\n      vec3 reflective2_374;\n      vec3 specular2_375;\n      vec3 diffuse2_376;\n      if ((i_370 >= rayBounces)) {\n        break;\n      };\n      if ((((reflectiveColor_369.x + reflectiveColor_369.y) + reflectiveColor_369.z) == 0.0)) {\n        break;\n      };\n      vec3 tmpvar_377;\n      tmpvar_377 = (V_367 - (2.0 * (\n        dot (N_368, V_367)\n       * N_368)));\n      V_367 = tmpvar_377;\n      vec3 ray_origin_378;\n      ray_origin_378 = P_366;\n      vec3 ray_direction_379;\n      ray_direction_379 = tmpvar_377;\n      float t_hit_380;\n      t_hit_380 = 20.0;\n      vec3 position_381;\n      vec3 normal_382;\n      vec3 diffuseColor_383;\n      diffuseColor_383 = diffuse2_376;\n      vec3 specularColor_384;\n      specularColor_384 = specular2_375;\n      vec3 reflectiveColor_385;\n      reflectiveColor_385 = reflective2_374;\n      float roughness_386;\n      roughness_386 = roughness2_373;\n      bool intersectLight_387;\n      intersectLight_387 = bool(1);\n      highp int idx_390;\n      highp int intersected_391;\n      intersected_391 = 0;\n      idx_390 = 0;\n      for (highp int i_389 = 0; i_389 < numSpheres; i_389++) {\n        float t_hit_392;\n        t_hit_392 = t_hit_380;\n        bool tmpvar_393;\n        vec3 tmpvar_394;\n        tmpvar_394 = (sphereCenters[i_389] - ray_origin_378);\n        float tmpvar_395;\n        tmpvar_395 = dot (tmpvar_394, ray_direction_379);\n        if ((tmpvar_395 < 0.0)) {\n          tmpvar_393 = bool(0);\n        } else {\n          float tmpvar_396;\n          tmpvar_396 = (dot (tmpvar_394, tmpvar_394) - (tmpvar_395 * tmpvar_395));\n          if ((tmpvar_396 > 0.64)) {\n            tmpvar_393 = bool(0);\n          } else {\n            float tmpvar_397;\n            tmpvar_397 = sqrt((0.64 - tmpvar_396));\n            float tmpvar_398;\n            tmpvar_398 = (tmpvar_395 - tmpvar_397);\n            float tmpvar_399;\n            tmpvar_399 = (tmpvar_395 + tmpvar_397);\n            float tmpvar_400;\n            if ((tmpvar_398 < 0.01)) {\n              tmpvar_400 = tmpvar_399;\n            } else {\n              tmpvar_400 = tmpvar_398;\n            };\n            if (((tmpvar_400 < t_hit_380) && (tmpvar_400 > 0.01))) {\n              t_hit_392 = tmpvar_400;\n              tmpvar_393 = bool(1);\n            } else {\n              tmpvar_393 = bool(0);\n            };\n          };\n        };\n        t_hit_380 = t_hit_392;\n        if (tmpvar_393) {\n          idx_390 = i_389;\n          intersected_391 = 1;\n        };\n      };\n      for (highp int i_388 = 0; i_388 < numPlanes; i_388++) {\n        vec3 tmpvar_401;\n        tmpvar_401 = planeNormals[i_388];\n        bool tmpvar_402;\n        if (enablePlaneBacksides) {\n          tmpvar_402 = bool(1);\n        } else {\n          tmpvar_402 = (dot (ray_direction_379, tmpvar_401) < 0.0);\n        };\n        if (tmpvar_402) {\n          float t_hit_403;\n          t_hit_403 = t_hit_380;\n          bool tmpvar_404;\n          tmpvar_404 = bool(1);\n          bool tmpvar_405;\n          vec3 tmpvar_406;\n          tmpvar_406 = (tmpvar_401 * planeOffsets[i_388]);\n          float tmpvar_407;\n          tmpvar_407 = (((\n            (tmpvar_406.x + tmpvar_406.y)\n           + tmpvar_406.z) - dot (tmpvar_401, ray_origin_378)) / dot (tmpvar_401, ray_direction_379));\n          if (((tmpvar_407 < t_hit_380) && (tmpvar_407 > 0.01))) {\n            t_hit_403 = tmpvar_407;\n            tmpvar_405 = bool(1);\n            tmpvar_404 = bool(0);\n          };\n          if (tmpvar_404) {\n            tmpvar_405 = bool(0);\n            tmpvar_404 = bool(0);\n          };\n          t_hit_380 = t_hit_403;\n          if (tmpvar_405) {\n            normal_382 = tmpvar_401;\n            idx_390 = i_388;\n            intersected_391 = 2;\n          };\n        };\n      };\n      intersectLight_387 = bool(0);\n      for (highp int i_408 = 0; i_408 < numLights; i_408++) {\n        bool tmp_409;\n        vec3 tmpvar_410;\n        tmpvar_410 = lightPos[i_408];\n        vec2 tmpvar_411;\n        tmpvar_411 = lightSize[i_408];\n        tmp_409 = bool(0);\n        if (((tmpvar_411.x > 0.0) && (tmpvar_411.y > 0.0))) {\n          float t_hit_412;\n          t_hit_412 = t_hit_380;\n          bool tmpvar_413;\n          tmpvar_413 = bool(1);\n          bool tmpvar_414;\n          vec3 tmpvar_415;\n          tmpvar_415 = (vec3(0.0, 1.0, 0.0) * tmpvar_410.y);\n          float tmpvar_416;\n          tmpvar_416 = (((\n            (tmpvar_415.x + tmpvar_415.y)\n           + tmpvar_415.z) - ray_origin_378.y) / ray_direction_379.y);\n          if (((tmpvar_416 < t_hit_380) && (tmpvar_416 > 0.01))) {\n            vec3 tmpvar_417;\n            tmpvar_417 = (ray_origin_378 + (ray_direction_379 * tmpvar_416));\n            if ((((tmpvar_411.x + tmpvar_411.y) == 0.0) || ((\n              ((tmpvar_417.x < (tmpvar_410.x + (tmpvar_411.x * 0.5))) && (tmpvar_417.x > (tmpvar_410.x - (tmpvar_411.x * 0.5))))\n             && \n              (tmpvar_417.z < (tmpvar_410.z + (tmpvar_411.y * 0.5)))\n            ) && (tmpvar_417.z > \n              (tmpvar_410.z - (tmpvar_411.y * 0.5))\n            )))) {\n              t_hit_412 = tmpvar_416;\n              tmpvar_414 = bool(1);\n              tmpvar_413 = bool(0);\n            };\n          };\n          if (tmpvar_413) {\n            tmpvar_414 = bool(0);\n            tmpvar_413 = bool(0);\n          };\n          t_hit_380 = t_hit_412;\n          tmp_409 = tmpvar_414;\n        } else {\n          float t_hit_418;\n          t_hit_418 = t_hit_380;\n          bool tmpvar_419;\n          vec3 tmpvar_420;\n          tmpvar_420 = (tmpvar_410 - ray_origin_378);\n          float tmpvar_421;\n          tmpvar_421 = dot (tmpvar_420, ray_direction_379);\n          if ((tmpvar_421 < 0.0)) {\n            tmpvar_419 = bool(0);\n          } else {\n            float tmpvar_422;\n            tmpvar_422 = (dot (tmpvar_420, tmpvar_420) - (tmpvar_421 * tmpvar_421));\n            if ((tmpvar_422 > 0.01)) {\n              tmpvar_419 = bool(0);\n            } else {\n              float tmpvar_423;\n              tmpvar_423 = sqrt((0.01 - tmpvar_422));\n              float tmpvar_424;\n              tmpvar_424 = (tmpvar_421 - tmpvar_423);\n              float tmpvar_425;\n              tmpvar_425 = (tmpvar_421 + tmpvar_423);\n              float tmpvar_426;\n              if ((tmpvar_424 < 0.01)) {\n                tmpvar_426 = tmpvar_425;\n              } else {\n                tmpvar_426 = tmpvar_424;\n              };\n              if (((tmpvar_426 < t_hit_380) && (tmpvar_426 > 0.01))) {\n                t_hit_418 = tmpvar_426;\n                tmpvar_419 = bool(1);\n              } else {\n                tmpvar_419 = bool(0);\n              };\n            };\n          };\n          t_hit_380 = t_hit_418;\n          tmp_409 = tmpvar_419;\n        };\n        if (tmp_409) {\n          idx_390 = i_408;\n          intersected_391 = 3;\n        };\n      };\n      position_381 = (P_366 + (tmpvar_377 * t_hit_380));\n      if ((intersected_391 == 1)) {\n        diffuseColor_383 = sphereColors[idx_390];\n        specularColor_384 = sphereSpecColors[idx_390];\n        reflectiveColor_385 = reflectiveColors[idx_390];\n        roughness_386 = sphereRoughness[idx_390];\n        vec3 tmpvar_427;\n        tmpvar_427 = normalize((position_381 - sphereCenters[idx_390]));\n        normal_382 = tmpvar_427;\n        float tmpvar_428;\n        tmpvar_428 = dot (tmpvar_427, -(tmpvar_377));\n        if ((tmpvar_428 < 0.0)) {\n          normal_382 = -(tmpvar_427);\n        };\n      } else {\n        if ((intersected_391 == 2)) {\n          if (!(enablePlaneMirrors)) {\n            diffuseColor_383 = planeColors[idx_390];\n            specularColor_384 = vec3(planeSpecular[idx_390]);\n            reflectiveColor_385 = vec3(0.0, 0.0, 0.0);\n            roughness_386 = planeRoughness[idx_390];\n          } else {\n            diffuseColor_383 = (planeColors[idx_390] * 0.01);\n            specularColor_384 = vec3(0.0, 0.0, 0.0);\n            reflectiveColor_385 = planeColors[idx_390];\n            roughness_386 = 1.0;\n          };\n          float tmpvar_429;\n          tmpvar_429 = dot (normal_382, -(tmpvar_377));\n          if ((tmpvar_429 < 0.0)) {\n            normal_382 = -(normal_382);\n          };\n        } else {\n          if ((intersected_391 == 3)) {\n            float spot_falloff_430;\n            spot_falloff_430 = 1.0;\n            vec2 tmpvar_431;\n            tmpvar_431 = lightSpot[idx_390];\n            if ((tmpvar_431.x > 0.0)) {\n              float tmpvar_432;\n              if ((tmpvar_377.y > tmpvar_431.x)) {\n                tmpvar_432 = pow (tmpvar_377.y, tmpvar_431.y);\n              } else {\n                tmpvar_432 = 0.0;\n              };\n              spot_falloff_430 = tmpvar_432;\n            };\n            diffuseColor_383 = ((spot_falloff_430 * lightBrightness[idx_390]) * 0.2);\n            intersectLight_387 = bool(1);\n          };\n        };\n      };\n      N_368 = normal_382;\n      diffuse2_376 = diffuseColor_383;\n      specular2_375 = specularColor_384;\n      reflective2_374 = reflectiveColor_385;\n      roughness2_373 = roughness_386;\n      vec3 tmpvar_433;\n      if (intersectLight_387) {\n        tmpvar_433 = diffuseColor_383;\n      } else {\n        vec3 P_434;\n        P_434 = position_381;\n        vec3 V_435;\n        V_435 = tmpvar_377;\n        vec3 N_436;\n        N_436 = normal_382;\n        vec3 diffuseColor_437;\n        diffuseColor_437 = diffuseColor_383;\n        vec3 specularColor_438;\n        specularColor_438 = specularColor_384;\n        highp int i_439;\n        vec3 illuminationColor_440;\n        i_439 = 0;\n        while (true) {\n          highp int k_441;\n          bool inShade_442;\n          highp int areaShadowSamples_443;\n          vec3 light_sum_444;\n          vec2 lightSpot_445;\n          vec2 lightSize_446;\n          vec3 lightBrightness_447;\n          vec3 lightPos_448;\n          if ((i_439 >= numLights)) {\n            break;\n          };\n          lightPos_448 = lightPos[i_439];\n          lightBrightness_447 = lightBrightness[i_439];\n          lightSize_446 = lightSize[i_439];\n          lightSpot_445 = lightSpot[i_439];\n          areaShadowSamples_443 = 0;\n          inShade_442 = bool(0);\n          k_441 = 0;\n          while (true) {\n            vec3 testPos_449;\n            if ((k_441 >= 1)) {\n              break;\n            };\n            if (inShade_442) {\n              break;\n            };\n            testPos_449 = lightPos_448;\n            if ((k_441 == 1)) {\n              testPos_449.x = (lightPos_448.x - (lightSize_446.x * 0.5));\n              testPos_449.z = (lightPos_448.z - (lightSize_446.y * 0.5));\n            } else {\n              if ((k_441 == 2)) {\n                testPos_449.x = (testPos_449.x + (lightSize_446.x * 0.5));\n                testPos_449.z = (testPos_449.z + (lightSize_446.y * 0.5));\n              } else {\n                if ((k_441 == 3)) {\n                  testPos_449.x = (testPos_449.x + (lightSize_446.x * 0.5));\n                  testPos_449.z = (testPos_449.z - (lightSize_446.y * 0.5));\n                } else {\n                  if ((k_441 == 4)) {\n                    testPos_449.x = (testPos_449.x - (lightSize_446.x * 0.5));\n                    testPos_449.z = (testPos_449.z + (lightSize_446.y * 0.5));\n                  };\n                };\n              };\n            };\n            vec3 L_450;\n            vec3 incidentIntensity_451;\n            float falloff_452;\n            L_450 = (testPos_449 - P_434);\n            float tmpvar_453;\n            tmpvar_453 = sqrt(dot (L_450, L_450));\n            float tmpvar_454;\n            tmpvar_454 = (1.0/(((attenuationFactor.x * \n              (tmpvar_453 * tmpvar_453)\n            ) + (attenuationFactor.y * tmpvar_453))));\n            vec3 tmpvar_455;\n            tmpvar_455 = normalize(L_450);\n            L_450 = tmpvar_455;\n            falloff_452 = 1.0;\n            if ((lightSpot_445.x > 0.0)) {\n              float tmpvar_456;\n              if ((tmpvar_455.y > lightSpot_445.x)) {\n                tmpvar_456 = pow (tmpvar_455.y, lightSpot_445.y);\n              } else {\n                tmpvar_456 = 0.0;\n              };\n              falloff_452 = tmpvar_456;\n            };\n            incidentIntensity_451 = ((lightBrightness_447 * tmpvar_454) * falloff_452);\n            float tmpvar_457;\n            tmpvar_457 = dot (N_436, tmpvar_455);\n            if (((tmpvar_457 > 0.0) && ((\n              (incidentIntensity_451.x + incidentIntensity_451.y)\n             + incidentIntensity_451.z) > 0.01))) {\n              vec3 ray_origin_458;\n              ray_origin_458 = P_434;\n              vec3 ray_direction_459;\n              ray_direction_459 = tmpvar_455;\n              float t_hit_460;\n              t_hit_460 = tmpvar_453;\n              bool tmpvar_461;\n              tmpvar_461 = bool(0);\n              highp int i_462;\n              highp int i_463;\n              i_463 = 0;\n              while (true) {\n                if ((i_463 >= numSpheres)) {\n                  break;\n                };\n                float t_hit_464;\n                t_hit_464 = t_hit_460;\n                bool tmpvar_465;\n                vec3 tmpvar_466;\n                tmpvar_466 = (sphereCenters[i_463] - ray_origin_458);\n                float tmpvar_467;\n                tmpvar_467 = dot (tmpvar_466, ray_direction_459);\n                if ((tmpvar_467 < 0.0)) {\n                  tmpvar_465 = bool(0);\n                } else {\n                  float tmpvar_468;\n                  tmpvar_468 = (dot (tmpvar_466, tmpvar_466) - (tmpvar_467 * tmpvar_467));\n                  if ((tmpvar_468 > 0.64)) {\n                    tmpvar_465 = bool(0);\n                  } else {\n                    float tmpvar_469;\n                    tmpvar_469 = sqrt((0.64 - tmpvar_468));\n                    float tmpvar_470;\n                    tmpvar_470 = (tmpvar_467 - tmpvar_469);\n                    float tmpvar_471;\n                    tmpvar_471 = (tmpvar_467 + tmpvar_469);\n                    float tmpvar_472;\n                    if ((tmpvar_470 < 0.001)) {\n                      tmpvar_472 = tmpvar_471;\n                    } else {\n                      tmpvar_472 = tmpvar_470;\n                    };\n                    if (((tmpvar_472 < t_hit_460) && (tmpvar_472 > 0.001))) {\n                      t_hit_464 = tmpvar_472;\n                      tmpvar_465 = bool(1);\n                    } else {\n                      tmpvar_465 = bool(0);\n                    };\n                  };\n                };\n                t_hit_460 = t_hit_464;\n                if (tmpvar_465) {\n                  tmpvar_461 = bool(1);\n                  break;\n                };\n                i_463++;\n              };\n              if (!(tmpvar_461)) {\n                i_462 = 0;\n                while (true) {\n                  if ((i_462 >= numPlanes)) {\n                    break;\n                  };\n                  vec3 normal_473;\n                  normal_473 = planeNormals[i_462];\n                  float t_hit_474;\n                  t_hit_474 = t_hit_460;\n                  bool tmpvar_475;\n                  tmpvar_475 = bool(1);\n                  bool tmpvar_476;\n                  vec3 tmpvar_477;\n                  tmpvar_477 = (normal_473 * planeOffsets[i_462]);\n                  float tmpvar_478;\n                  tmpvar_478 = (((\n                    (tmpvar_477.x + tmpvar_477.y)\n                   + tmpvar_477.z) - dot (normal_473, ray_origin_458)) / dot (normal_473, ray_direction_459));\n                  if (((tmpvar_478 < t_hit_460) && (tmpvar_478 > 0.001))) {\n                    t_hit_474 = tmpvar_478;\n                    tmpvar_476 = bool(1);\n                    tmpvar_475 = bool(0);\n                  };\n                  if (tmpvar_475) {\n                    tmpvar_476 = bool(0);\n                    tmpvar_475 = bool(0);\n                  };\n                  t_hit_460 = t_hit_474;\n                  if (tmpvar_476) {\n                    tmpvar_461 = bool(1);\n                    break;\n                  };\n                  i_462++;\n                };\n                if (!(tmpvar_461)) {\n                  tmpvar_461 = bool(1);\n                };\n              };\n              float tmpvar_479;\n              tmpvar_479 = abs((t_hit_460 - tmpvar_453));\n              if ((tmpvar_479 < 0.001)) {\n                vec3 I_480;\n                I_480 = -(tmpvar_455);\n                light_sum_444 = (light_sum_444 + (incidentIntensity_451 * (\n                  (diffuseColor_437 * dot (N_436, tmpvar_455))\n                 + \n                  (specularColor_438 * pow (max (0.0, dot (\n                    (I_480 - (2.0 * (dot (N_436, I_480) * N_436)))\n                  , \n                    -(V_435)\n                  )), 128.0))\n                )));\n              } else {\n                inShade_442 = bool(1);\n              };\n            } else {\n              inShade_442 = bool(1);\n            };\n            areaShadowSamples_443++;\n            k_441++;\n          };\n          illuminationColor_440 = (illuminationColor_440 + (light_sum_444 / float(areaShadowSamples_443)));\n          i_439++;\n        };\n        tmpvar_433 = illuminationColor_440;\n      };\n      mirror_sample_color_372 = tmpvar_433;\n      if (enableRefGI) {\n        vec3 P_481;\n        P_481 = position_381;\n        vec3 N_482;\n        N_482 = normal_382;\n        highp int i_483;\n        vec3 indirect_sampling_sum_484;\n        i_483 = 0;\n        while (true) {\n          float roughness2_485;\n          vec3 reflective2_486;\n          vec3 specular2_487;\n          vec3 diffuse2_488;\n          if ((i_483 >= indirectSamples)) {\n            break;\n          };\n          float sampleIdx_489;\n          sampleIdx_489 = float(i_483);\n          randomIncrement += 0.02;\n          float tmpvar_490;\n          tmpvar_490 = ((1.0 - (\n            (sampleIdx_489 / float((indirectSamples - 1)))\n           * 2.0)) + ((\n            fract((cos(dot (\n              (P_481.xy + randomIncrement)\n            , vec2(23.14069, 2.665144))) * 12345.68))\n           * 0.4) - 0.2));\n          float tmpvar_491;\n          tmpvar_491 = sqrt((1.0 - (tmpvar_490 * tmpvar_490)));\n          randomIncrement += 0.02;\n          float tmpvar_492;\n          tmpvar_492 = ((2.399963 * sampleIdx_489) + ((\n            fract((cos(dot (\n              (P_481.xy + randomIncrement)\n            , vec2(23.14069, 2.665144))) * 12345.68))\n           * 0.5) - 0.25));\n          vec3 tmpvar_493;\n          tmpvar_493.x = (cos(tmpvar_492) * tmpvar_491);\n          tmpvar_493.y = tmpvar_490;\n          tmpvar_493.z = (sin(tmpvar_492) * tmpvar_491);\n          vec3 ray_origin_494;\n          ray_origin_494 = P_481;\n          vec3 ray_direction_495;\n          ray_direction_495 = normalize(normalize((N_482 + tmpvar_493)));\n          float t_hit_496;\n          t_hit_496 = 10.0;\n          vec3 position_497;\n          vec3 normal_498;\n          vec3 diffuseColor_499;\n          diffuseColor_499 = diffuse2_488;\n          vec3 specularColor_500;\n          specularColor_500 = specular2_487;\n          vec3 reflectiveColor_501;\n          reflectiveColor_501 = reflective2_486;\n          float roughness_502;\n          roughness_502 = roughness2_485;\n          highp int i_503;\n          highp int i_504;\n          highp int idx_505;\n          highp int intersected_506;\n          intersected_506 = 0;\n          idx_505 = 0;\n          i_504 = 0;\n          while (true) {\n            if ((i_504 >= numSpheres)) {\n              break;\n            };\n            float t_hit_507;\n            t_hit_507 = t_hit_496;\n            bool tmpvar_508;\n            vec3 tmpvar_509;\n            tmpvar_509 = (sphereCenters[i_504] - ray_origin_494);\n            float tmpvar_510;\n            tmpvar_510 = dot (tmpvar_509, ray_direction_495);\n            if ((tmpvar_510 < 0.0)) {\n              tmpvar_508 = bool(0);\n            } else {\n              float tmpvar_511;\n              tmpvar_511 = (dot (tmpvar_509, tmpvar_509) - (tmpvar_510 * tmpvar_510));\n              if ((tmpvar_511 > 0.64)) {\n                tmpvar_508 = bool(0);\n              } else {\n                float tmpvar_512;\n                tmpvar_512 = sqrt((0.64 - tmpvar_511));\n                float tmpvar_513;\n                tmpvar_513 = (tmpvar_510 - tmpvar_512);\n                float tmpvar_514;\n                tmpvar_514 = (tmpvar_510 + tmpvar_512);\n                float tmpvar_515;\n                if ((tmpvar_513 < 0.01)) {\n                  tmpvar_515 = tmpvar_514;\n                } else {\n                  tmpvar_515 = tmpvar_513;\n                };\n                if (((tmpvar_515 < t_hit_496) && (tmpvar_515 > 0.01))) {\n                  t_hit_507 = tmpvar_515;\n                  tmpvar_508 = bool(1);\n                } else {\n                  tmpvar_508 = bool(0);\n                };\n              };\n            };\n            t_hit_496 = t_hit_507;\n            if (tmpvar_508) {\n              idx_505 = i_504;\n              intersected_506 = 1;\n            };\n            i_504++;\n          };\n          i_503 = 0;\n          while (true) {\n            if ((i_503 >= numPlanes)) {\n              break;\n            };\n            vec3 tmpvar_516;\n            tmpvar_516 = planeNormals[i_503];\n            bool tmpvar_517;\n            if (enablePlaneBacksides) {\n              tmpvar_517 = bool(1);\n            } else {\n              tmpvar_517 = (dot (ray_direction_495, tmpvar_516) < 0.0);\n            };\n            if (tmpvar_517) {\n              float t_hit_518;\n              t_hit_518 = t_hit_496;\n              bool tmpvar_519;\n              tmpvar_519 = bool(1);\n              bool tmpvar_520;\n              vec3 tmpvar_521;\n              tmpvar_521 = (tmpvar_516 * planeOffsets[i_503]);\n              float tmpvar_522;\n              tmpvar_522 = (((\n                (tmpvar_521.x + tmpvar_521.y)\n               + tmpvar_521.z) - dot (tmpvar_516, ray_origin_494)) / dot (tmpvar_516, ray_direction_495));\n              if (((tmpvar_522 < t_hit_496) && (tmpvar_522 > 0.01))) {\n                t_hit_518 = tmpvar_522;\n                tmpvar_520 = bool(1);\n                tmpvar_519 = bool(0);\n              };\n              if (tmpvar_519) {\n                tmpvar_520 = bool(0);\n                tmpvar_519 = bool(0);\n              };\n              t_hit_496 = t_hit_518;\n              if (tmpvar_520) {\n                normal_498 = tmpvar_516;\n                idx_505 = i_503;\n                intersected_506 = 2;\n              };\n            };\n            i_503++;\n          };\n          position_497 = (P_481 + (ray_direction_495 * t_hit_496));\n          if ((intersected_506 == 1)) {\n            diffuseColor_499 = sphereColors[idx_505];\n            specularColor_500 = sphereSpecColors[idx_505];\n            reflectiveColor_501 = reflectiveColors[idx_505];\n            roughness_502 = sphereRoughness[idx_505];\n            vec3 tmpvar_523;\n            tmpvar_523 = normalize((position_497 - sphereCenters[idx_505]));\n            normal_498 = tmpvar_523;\n            float tmpvar_524;\n            tmpvar_524 = dot (tmpvar_523, -(ray_direction_495));\n            if ((tmpvar_524 < 0.0)) {\n              normal_498 = -(tmpvar_523);\n            };\n          } else {\n            if ((intersected_506 == 2)) {\n              if (!(enablePlaneMirrors)) {\n                diffuseColor_499 = planeColors[idx_505];\n                specularColor_500 = vec3(planeSpecular[idx_505]);\n                reflectiveColor_501 = vec3(0.0, 0.0, 0.0);\n                roughness_502 = planeRoughness[idx_505];\n              } else {\n                diffuseColor_499 = (planeColors[idx_505] * 0.01);\n                specularColor_500 = vec3(0.0, 0.0, 0.0);\n                reflectiveColor_501 = planeColors[idx_505];\n                roughness_502 = 1.0;\n              };\n              float tmpvar_525;\n              tmpvar_525 = dot (normal_498, -(ray_direction_495));\n              if ((tmpvar_525 < 0.0)) {\n                normal_498 = -(normal_498);\n              };\n            } else {\n              if ((intersected_506 == 3)) {\n                float spot_falloff_526;\n                spot_falloff_526 = 1.0;\n                vec2 tmpvar_527;\n                tmpvar_527 = lightSpot[idx_505];\n                if ((tmpvar_527.x > 0.0)) {\n                  float tmpvar_528;\n                  if ((ray_direction_495.y > tmpvar_527.x)) {\n                    tmpvar_528 = pow (ray_direction_495.y, tmpvar_527.y);\n                  } else {\n                    tmpvar_528 = 0.0;\n                  };\n                  spot_falloff_526 = tmpvar_528;\n                };\n                diffuseColor_499 = ((spot_falloff_526 * lightBrightness[idx_505]) * 0.2);\n              };\n            };\n          };\n          diffuse2_488 = diffuseColor_499;\n          specular2_487 = specularColor_500;\n          reflective2_486 = reflectiveColor_501;\n          roughness2_485 = roughness_502;\n          vec3 P_529;\n          P_529 = position_497;\n          vec3 N_530;\n          N_530 = normal_498;\n          vec3 diffuseColor_531;\n          diffuseColor_531 = (diffuseColor_499 + reflectiveColor_501);\n          highp int i_532;\n          vec3 illuminationColor_533;\n          i_532 = 0;\n          while (true) {\n            float spotAttenuation_534;\n            if ((i_532 >= numLights)) {\n              break;\n            };\n            vec3 tmpvar_535;\n            tmpvar_535 = (lightPos[i_532] - P_529);\n            float tmpvar_536;\n            tmpvar_536 = sqrt(dot (tmpvar_535, tmpvar_535));\n            vec3 tmpvar_537;\n            tmpvar_537 = normalize(tmpvar_535);\n            vec2 tmpvar_538;\n            tmpvar_538 = lightSpot[i_532];\n            spotAttenuation_534 = 1.0;\n            if ((tmpvar_538.x > 0.0)) {\n              float tmpvar_539;\n              if ((tmpvar_537.y > tmpvar_538.x)) {\n                tmpvar_539 = pow (tmpvar_537.y, tmpvar_538.y);\n              } else {\n                tmpvar_539 = 0.0;\n              };\n              spotAttenuation_534 = tmpvar_539;\n            };\n            if ((spotAttenuation_534 > 0.0)) {\n              vec3 lightBrightness_540;\n              lightBrightness_540 = lightBrightness[i_532];\n              float tmpvar_541;\n              tmpvar_541 = (1.0/(((attenuationFactor.x * \n                (tmpvar_536 * tmpvar_536)\n              ) + (attenuationFactor.y * tmpvar_536))));\n              if ((tmpvar_541 > 0.004)) {\n                float tmpvar_542;\n                tmpvar_542 = dot (N_530, tmpvar_537);\n                if ((tmpvar_542 > 0.0)) {\n                  vec3 ray_origin_543;\n                  ray_origin_543 = P_529;\n                  vec3 ray_direction_544;\n                  ray_direction_544 = tmpvar_537;\n                  float t_hit_545;\n                  t_hit_545 = tmpvar_536;\n                  bool tmpvar_546;\n                  bool tmpvar_547;\n                  tmpvar_547 = bool(0);\n                  highp int i_548;\n                  highp int i_549;\n                  i_549 = 0;\n                  while (true) {\n                    if ((i_549 >= numSpheres)) {\n                      break;\n                    };\n                    float t_hit_550;\n                    t_hit_550 = t_hit_545;\n                    bool tmpvar_551;\n                    vec3 tmpvar_552;\n                    tmpvar_552 = (sphereCenters[i_549] - ray_origin_543);\n                    float tmpvar_553;\n                    tmpvar_553 = dot (tmpvar_552, ray_direction_544);\n                    if ((tmpvar_553 < 0.0)) {\n                      tmpvar_551 = bool(0);\n                    } else {\n                      float tmpvar_554;\n                      tmpvar_554 = (dot (tmpvar_552, tmpvar_552) - (tmpvar_553 * tmpvar_553));\n                      if ((tmpvar_554 > 0.64)) {\n                        tmpvar_551 = bool(0);\n                      } else {\n                        float tmpvar_555;\n                        tmpvar_555 = sqrt((0.64 - tmpvar_554));\n                        float tmpvar_556;\n                        tmpvar_556 = (tmpvar_553 - tmpvar_555);\n                        float tmpvar_557;\n                        tmpvar_557 = (tmpvar_553 + tmpvar_555);\n                        float tmpvar_558;\n                        if ((tmpvar_556 < 0.001)) {\n                          tmpvar_558 = tmpvar_557;\n                        } else {\n                          tmpvar_558 = tmpvar_556;\n                        };\n                        if (((tmpvar_558 < t_hit_545) && (tmpvar_558 > 0.001))) {\n                          t_hit_550 = tmpvar_558;\n                          tmpvar_551 = bool(1);\n                        } else {\n                          tmpvar_551 = bool(0);\n                        };\n                      };\n                    };\n                    t_hit_545 = t_hit_550;\n                    if (tmpvar_551) {\n                      tmpvar_546 = bool(1);\n                      tmpvar_547 = bool(1);\n                      break;\n                    };\n                    i_549++;\n                  };\n                  if (!(tmpvar_547)) {\n                    i_548 = 0;\n                    while (true) {\n                      if ((i_548 >= numPlanes)) {\n                        break;\n                      };\n                      vec3 normal_559;\n                      normal_559 = planeNormals[i_548];\n                      float t_hit_560;\n                      t_hit_560 = t_hit_545;\n                      bool tmpvar_561;\n                      tmpvar_561 = bool(1);\n                      bool tmpvar_562;\n                      vec3 tmpvar_563;\n                      tmpvar_563 = (normal_559 * planeOffsets[i_548]);\n                      float tmpvar_564;\n                      tmpvar_564 = (((\n                        (tmpvar_563.x + tmpvar_563.y)\n                       + tmpvar_563.z) - dot (normal_559, ray_origin_543)) / dot (normal_559, ray_direction_544));\n                      if (((tmpvar_564 < t_hit_545) && (tmpvar_564 > 0.001))) {\n                        t_hit_560 = tmpvar_564;\n                        tmpvar_562 = bool(1);\n                        tmpvar_561 = bool(0);\n                      };\n                      if (tmpvar_561) {\n                        tmpvar_562 = bool(0);\n                        tmpvar_561 = bool(0);\n                      };\n                      t_hit_545 = t_hit_560;\n                      if (tmpvar_562) {\n                        tmpvar_546 = bool(1);\n                        tmpvar_547 = bool(1);\n                        break;\n                      };\n                      i_548++;\n                    };\n                    if (!(tmpvar_547)) {\n                      tmpvar_546 = bool(0);\n                      tmpvar_547 = bool(1);\n                    };\n                  };\n                  if (!(tmpvar_546)) {\n                    illuminationColor_533 = (illuminationColor_533 + ((diffuseColor_531 * lightBrightness_540) * (\n                      (tmpvar_541 * spotAttenuation_534)\n                     * tmpvar_542)));\n                  };\n                };\n              };\n            };\n            i_532++;\n          };\n          indirect_sampling_sum_484 = (indirect_sampling_sum_484 + illuminationColor_533);\n          i_483++;\n        };\n        mirror_sample_color_372 = (tmpvar_433 + ((indirect_sampling_sum_484 / \n          float(indirectSamples)\n        ) * diffuseColor_383));\n      } else {\n        mirror_sample_color_372 = (mirror_sample_color_372 + (ambientLight * diffuseColor_383));\n      };\n      P_366 = position_381;\n      reflectionSum_371 = (reflectionSum_371 + (mirror_sample_color_372 * reflectiveColor_369));\n      reflectiveColor_369 = (reflectiveColor_385 * reflectiveColor_369);\n      i_370++;\n    };\n    pixelColor_5 = (pixelColor_5 + reflectionSum_371);\n  };\n  lowp vec3 x_565;\n  x_565 = (mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777) * pixelColor_5);\n  x_565 = (((x_565 * \n    (x_565 + 0.0245786)\n  ) - 9.0537e-05) / ((x_565 * \n    ((0.983729 * x_565) + 0.432951)\n  ) + 0.238081));\n  x_565 = (mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602) * x_565);\n  lowp vec3 tmpvar_566;\n  tmpvar_566 = clamp (x_565, 0.0, 1.0);\n  pixelColor_5 = tmpvar_566;\n  lowp vec3 tmpvar_567;\n  tmpvar_567 = pow (tmpvar_566, vec3(0.4545454, 0.4545454, 0.4545454));\n  float tmpvar_568;\n  if ((tmpvar_566.x < 0.0031308)) {\n    tmpvar_568 = 1.0;\n  } else {\n    tmpvar_568 = 0.0;\n  };\n  float tmpvar_569;\n  if ((tmpvar_566.y < 0.0031308)) {\n    tmpvar_569 = 1.0;\n  } else {\n    tmpvar_569 = 0.0;\n  };\n  float tmpvar_570;\n  if ((tmpvar_566.z < 0.0031308)) {\n    tmpvar_570 = 1.0;\n  } else {\n    tmpvar_570 = 0.0;\n  };\n  vec3 tmpvar_571;\n  tmpvar_571.x = tmpvar_568;\n  tmpvar_571.y = tmpvar_569;\n  tmpvar_571.z = tmpvar_570;\n  lowp vec3 tmpvar_572;\n  tmpvar_572 = mix (((tmpvar_567 * 1.055) - 0.055), (tmpvar_566 * 12.92), tmpvar_571);\n  pixelColor_5 = tmpvar_572;\n  if (enableTAA) {\n    lowp vec4 tmpvar_573;\n    tmpvar_573.w = 1.0;\n    tmpvar_573.xyz = tmpvar_572;\n    fragColor = ((0.1 * tmpvar_573) + (0.9 * texture (u_texture, texCoord)));\n  } else {\n    lowp vec4 tmpvar_574;\n    tmpvar_574.w = 1.0;\n    tmpvar_574.xyz = tmpvar_572;\n    fragColor = tmpvar_574;\n  };\n}\n\n"},675:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform mat4 invprojview;\nuniform float near;\nuniform float far;\n\nout vec3 origin;\nout vec3 ray;\nout vec2 texCoord;\n\nvoid main() {\n    // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/\n    float x = -1.0 + float((gl_VertexID & 1) << 2);\n    float y = -1.0 + float((gl_VertexID & 2) << 1);\n    texCoord.x = (x+1.0)*0.5;\n    texCoord.y = (y+1.0)*0.5;\n    gl_Position = vec4(x, y, 0, 1);\n                \n    // https://stackoverflow.com/a/52764898\n    origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;\n    ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;\n}"}},t={};function r(_){var a=t[_];if(void 0!==a)return a.exports;var e=t[_]={id:_,exports:{}};return n[_](e,e.exports,r),e.exports}r.n=n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return r.d(t,{a:t}),t},r.d=(n,t)=>{for(var _ in t)r.o(t,_)&&!r.o(n,_)&&Object.defineProperty(n,_,{enumerable:!0,get:t[_]})},r.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),r(84),r(548)})();