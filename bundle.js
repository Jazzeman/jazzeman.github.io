(()=>{"use strict";var n={84:(n,t,r)=>{var _="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var a=Math.PI/180;function e(){var n=new _(16);return _!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function o(n,t){var r=t[0],_=t[1],a=t[2],e=t[3],o=t[4],i=t[5],p=t[6],m=t[7],v=t[8],l=t[9],s=t[10],f=t[11],c=t[12],h=t[13],d=t[14],u=t[15],g=r*i-_*o,b=r*p-a*o,y=r*m-e*o,x=_*p-a*i,C=_*m-e*i,S=a*m-e*p,z=v*h-l*c,P=v*d-s*c,w=v*u-f*c,E=l*d-s*h,L=l*u-f*h,I=s*u-f*d,k=g*I-b*L+y*E+x*w-C*P+S*z;return k?(k=1/k,n[0]=(i*I-p*L+m*E)*k,n[1]=(a*L-_*I-e*E)*k,n[2]=(h*S-d*C+u*x)*k,n[3]=(s*C-l*S-f*x)*k,n[4]=(p*w-o*I-m*P)*k,n[5]=(r*I-a*w+e*P)*k,n[6]=(d*y-c*S-u*b)*k,n[7]=(v*S-s*y+f*b)*k,n[8]=(o*L-i*w+m*z)*k,n[9]=(_*w-r*L-e*z)*k,n[10]=(c*C-h*y+u*g)*k,n[11]=(l*y-v*C-f*g)*k,n[12]=(i*P-o*E-p*z)*k,n[13]=(r*E-_*P+a*z)*k,n[14]=(h*b-c*x-d*g)*k,n[15]=(v*x-l*b+s*g)*k,n):null}Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)});var i=function(n,t,r){var _=t[0],a=t[1],e=t[2],o=t[3],i=t[4],p=t[5],m=t[6],v=t[7],l=t[8],s=t[9],f=t[10],c=t[11],h=t[12],d=t[13],u=t[14],g=t[15],b=r[0],y=r[1],x=r[2],C=r[3];return n[0]=b*_+y*i+x*l+C*h,n[1]=b*a+y*p+x*s+C*d,n[2]=b*e+y*m+x*f+C*u,n[3]=b*o+y*v+x*c+C*g,b=r[4],y=r[5],x=r[6],C=r[7],n[4]=b*_+y*i+x*l+C*h,n[5]=b*a+y*p+x*s+C*d,n[6]=b*e+y*m+x*f+C*u,n[7]=b*o+y*v+x*c+C*g,b=r[8],y=r[9],x=r[10],C=r[11],n[8]=b*_+y*i+x*l+C*h,n[9]=b*a+y*p+x*s+C*d,n[10]=b*e+y*m+x*f+C*u,n[11]=b*o+y*v+x*c+C*g,b=r[12],y=r[13],x=r[14],C=r[15],n[12]=b*_+y*i+x*l+C*h,n[13]=b*a+y*p+x*s+C*d,n[14]=b*e+y*m+x*f+C*u,n[15]=b*o+y*v+x*c+C*g,n};function p(n,t,r){var _=n.createShader(t);if(n.shaderSource(_,r),n.compileShader(_),n.getShaderParameter(_,n.COMPILE_STATUS))return _;console.log(n.getShaderInfoLog(_)),n.deleteShader(_)}function m(n){var t=n.createTexture();return n.bindTexture(n.TEXTURE_2D,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),t}function v(n,t,r){n.canvas.width=t,n.canvas.height=r,n.viewport(0,0,n.canvas.width,n.canvas.height)}var l=r(675),s=r(574);const f=JSON.parse('{"nS":{"x":0,"y":0,"z":16,"fx":0,"tW":-0.05,"Bp":0.7,"On":0.1,"NC":50},"H":[{"x":0,"y":3.999999,"z":0,"r":1,"g":1,"b":1,"sizeX":1,"sizeY":1,"brightness":100,"spotSize":0.001,"spotIntensity":1.5,"rotate":false,"enabled":true},{"x":-3.3,"y":2.5,"z":0,"r":1,"g":1,"b":1,"sizeX":0.3,"sizeY":0.3,"brightness":100,"spotSize":0.9,"spotIntensity":0,"rotate":true,"enabled":false}],"vi":[{"x":1.25,"y":-1.5,"z":-1.5,"r":0.9,"g":0.5,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":2.5,"y":-3.2,"z":-1.5,"r":0,"g":0,"b":0,"rr":1,"rg":1,"rb":1,"sr":1,"sg":1,"sb":1,"roughness":1},{"x":0,"y":-3.2,"z":-1.5,"r":0.9,"g":0.1,"b":0.1,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.35},{"x":-2.5,"y":-3.2,"z":-1.5,"r":0.1,"g":0.9,"b":0.9,"rr":0,"rg":0,"rb":0,"sr":0,"sg":0,"sb":0,"roughness":0.5}],"Rm":[{"x":0,"y":1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"floor"},{"x":0,"y":-1,"z":0,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"ceiling"},{"x":-1,"y":0,"z":0,"r":1,"g":0.1,"b":0.1,"specular":0,"roughness":1,"offset":4,"enabled":true,"desc":"right wall"},{"x":1,"y":0,"z":0,"r":0.1,"g":1,"b":0.1,"specular":0,"roughness":1,"offset":-4,"enabled":true,"desc":"left wall"},{"x":0,"y":0,"z":1,"r":0.9,"g":0.9,"b":0.5,"specular":0,"roughness":0.25,"offset":-4,"enabled":true,"desc":"back wall"},{"x":0,"y":0,"z":-1,"r":1,"g":1,"b":1,"specular":0,"roughness":1,"offset":4,"enabled":false,"desc":"front wall"}]}');var c=document.getElementById("fps"),h=!0,d=!0,u=!1,g=!1,b=!1,y=!1,x=!1,C=0,S=0,z=0,P=0,w=document.querySelector("#canvas"),E=w.getContext("webgl2",{powerPreference:"high-performance",antialias:!1,alpha:!0,stencil:!1,depth:!1,desynchronized:!1,preserveDrawingBuffer:!1}),L=function(n,t,r){console.log("COMPILING SHADERS");var _=p(n,n.VERTEX_SHADER,t),a=p(n,n.FRAGMENT_SHADER,r);console.log("CREATING PROGRAM"),v(n,1280,720),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT);var e=function(n,t,r){var _=n.createProgram();if(n.attachShader(_,t),n.attachShader(_,r),n.linkProgram(_),n.getProgramParameter(_,n.LINK_STATUS))return _;console.log(n.getProgramInfoLog(_)),n.deleteProgram(_)}(n,_,a);return n.useProgram(e),console.log("FINISH"),e}(E,l,s),I=E.getUniformLocation(L,"enableTAA"),k=E.getUniformLocation(L,"randomseed"),R=(E.getUniformLocation(L,"sphereCenters[0]"),E.getUniformLocation(L,"u_texture")),T=m(E);E.texImage2D(E.TEXTURE_2D,0,E.RGBA,E.canvas.width,E.canvas.height,0,E.RGBA,E.UNSIGNED_BYTE,null);var A=E.createFramebuffer();E.bindFramebuffer(E.DRAW_FRAMEBUFFER,A),E.framebufferTexture2D(E.DRAW_FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,T,0);var N=m(E);E.texImage2D(E.TEXTURE_2D,0,E.RGBA,E.canvas.width,E.canvas.height,0,E.RGBA,E.UNSIGNED_BYTE,null);var B=E.createFramebuffer();E.bindFramebuffer(E.DRAW_FRAMEBUFFER,B),E.framebufferTexture2D(E.DRAW_FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,N,0);var M=!0,U=!0,F=50,D=1,q=!0,G=9,O=!0,V=!1,X=1.5,H=0,W=f.nS.On,Y=f.nS.NC,j=f.nS.Bp,K=f.nS.x,Z=f.nS.y,J=f.nS.z,Q=f.nS.fx,$=f.nS.tW,nn=e(),tn=e(),rn=e(),_n=e(),an=e(),en=e();function on(n){var t,r,_,a;g&&(K+=4*n*Math.cos($)*Math.cos(Q+Math.PI/2),Z+=4*n*Math.sin($),J-=4*n*Math.cos($)*Math.sin(Q+Math.PI/2)),y&&(K-=4*n*Math.cos($)*Math.cos(Q+Math.PI/2),Z-=4*n*Math.sin($),J+=4*n*Math.cos($)*Math.sin(Q+Math.PI/2)),b&&(K+=4*n*Math.cos(Q+Math.PI),J-=4*n*Math.sin(Q+Math.PI)),x&&(K+=4*n*Math.cos(Q),J-=4*n*Math.sin(Q)),function(n,t,r,_,a){var e,o=1/Math.tan(t/2);n[0]=o/r,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=o,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,null!=a&&a!==1/0?(e=1/(_-a),n[10]=(a+_)*e,n[14]=2*a*_*e):(n[10]=-1,n[14]=-2*_)}(nn,j,E.canvas.width/E.canvas.height,W,Y),t=tn,r=Q,_=Math.sin(r),a=Math.cos(r),t[0]=a,t[1]=0,t[2]=-_,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=_,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,function(n,t){var r=Math.sin(t),_=Math.cos(t);n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=_,n[6]=r,n[7]=0,n[8]=0,n[9]=-r,n[10]=_,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1}(rn,$),function(n,t){n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=t[0],n[13]=t[1],n[14]=t[2],n[15]=1}(_n,[K,Z,J]),i(an,tn,rn),i(an,_n,an),o(an,an),i(en,nn,an),o(en,en),E.uniform1f(E.getUniformLocation(L,"near"),W),E.uniform1f(E.getUniformLocation(L,"far"),Y),E.uniformMatrix4fv(E.getUniformLocation(L,"invprojview"),!1,en)}function pn(){for(var n=[],t=0;t<f.Rm.length;t++)f.Rm[t].enabled&&n.push(f.Rm[t]);var r=n.length;E.uniform1i(E.getUniformLocation(L,"numPlanes"),r);for(var _=0;_<r;_++){var a=E.getUniformLocation(L,"planeOffsets["+_+"]"),e=E.getUniformLocation(L,"planeNormals["+_+"]"),o=E.getUniformLocation(L,"planeColors["+_+"]"),i=E.getUniformLocation(L,"planeSpecular["+_+"]"),p=E.getUniformLocation(L,"planeRoughness["+_+"]");E.uniform1f(a,n[_].offset),E.uniform3f(e,n[_].x,n[_].y,n[_].z),E.uniform3f(o,n[_].r,n[_].g,n[_].b),E.uniform1f(i,n[_].specular),E.uniform1f(p,n[_].roughness)}}function mn(){var n=f.H.filter((function(n){return n.enabled})),t=n.length;E.uniform1i(E.getUniformLocation(L,"numLights"),t);for(var r=0;r<t;r++){var _=n[r],a=E.getUniformLocation(L,"lightPos["+r+"]"),e=E.getUniformLocation(L,"lightSize["+r+"]"),o=E.getUniformLocation(L,"lightBrightness["+r+"]"),i=E.getUniformLocation(L,"lightSpot["+r+"]");E.uniform3f(a,_.x,_.y,_.z),E.uniform2f(e,q?_.sizeX:0,q?_.sizeY:0),E.uniform3f(o,_.r*_.brightness,_.g*_.brightness,_.b*_.brightness),E.uniform2f(i,_.spotSize,_.spotIntensity)}}function vn(){E.uniform3f(E.getUniformLocation(L,"ambientLight"),.01,.01,.01),E.uniform1i(E.getUniformLocation(L,"enableGI"),M),E.uniform1i(E.getUniformLocation(L,"enableRefGI"),U),E.uniform1i(E.getUniformLocation(L,"indirectSamples"),F),E.uniform1i(E.getUniformLocation(L,"rayBounces"),D);var n=Math.floor(Math.sqrt(G));E.uniform1f(E.getUniformLocation(L,"shadowDim"),n),E.uniform1i(E.getUniformLocation(L,"shadowSamples"),Math.pow(n,2)),E.uniform1i(E.getUniformLocation(L,"enablePlaneBacksides"),O),E.uniform1i(E.getUniformLocation(L,"enablePlaneMirrors"),V),E.uniform2f(E.getUniformLocation(L,"attenuationFactor"),X,H)}function ln(){w.style.width=window.innerWidth,w.style.height=window.innerHeight;var n=Math.floor(window.innerWidth*window.devicePixelRatio),t=Math.floor(window.innerHeight*window.devicePixelRatio);E.bindTexture(E.TEXTURE_2D,T),E.texImage2D(E.TEXTURE_2D,0,E.RGBA,n,t,0,E.RGBA,E.UNSIGNED_BYTE,null),E.bindTexture(E.TEXTURE_2D,null),E.bindTexture(E.TEXTURE_2D,N),E.texImage2D(E.TEXTURE_2D,0,E.RGBA,n,t,0,E.RGBA,E.UNSIGNED_BYTE,null),E.bindTexture(E.TEXTURE_2D,null),v(E,n,t),on()}function sn(n,t){var r=document.getElementById("lightcontrols"),_="\n        <br>\n        <b>light ".concat(n+1,'</b><br>\n        <input type="checkbox" ').concat(t[n].enabled&&"checked",' id="').concat(n,'" class="light-enable"> on/off<br>\n        <table class="sliders">\n            <tr>\n                <td><label>Bright:</label></td>\n                <td><input type="range" min="0" max="200" step="0.1" value="').concat(t[n].brightness,'" id="').concat(n,'" class="light-brightness"></td>\n            </tr>\n            <tr>\n                <td><label>Spot size:</label></td>\n                <td><input type="range" min="0" max="1" step="0.01" value="').concat(1-t[n].spotSize,'" id="').concat(n,'" class="light-spotsize"></td>\n            </tr>\n            <tr>\n                <td><label>Spot falloff:</label></td>\n                <td><input type="range" min="0" max="4" step="0.01" value="').concat(t[n].spotIntensity,'" id="').concat(n,'" class="light-spotintensity"></td>\n            </tr>\n            <tr>\n                <td><label>r:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'r" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>g:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'g" class="light-color"></td>\n            </tr>\n            <tr>\n                <td><label>b:</label></td>\n                <td><input type="range" min="0" max="1" value="1" step="0.1" id="').concat(n,'b" class="light-color"></td>\n            </tr>\n                <td><label>sizeX:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(t[n].sizeX,'" id="').concat(n,'x" class="light-size"></td>\n            <tr>\n                <td><label>sizeY:</label></td>\n                <td><input type="range" min="0" max="3" step="0.01" value="').concat(t[n].sizeY,'" id="').concat(n,'y" class="light-size"></td>\n            </tr>\n        </table>');r.insertAdjacentHTML("beforeend",_)}function fn(n,t){var r=document.getElementById("planecontrols"),_='\n        <input type="checkbox" id="'.concat(n,'" class="plane-enable" ').concat(t[n].enabled&&"checked","><b>").concat(t[n].desc,"</b><br>");r.insertAdjacentHTML("beforeend",_)}ln(),pn(),function(){var n=f.vi.length;E.uniform1i(E.getUniformLocation(L,"numSpheres"),n);for(var t=0;t<n;t++){var r=f.vi[t],_=E.getUniformLocation(L,"sphereCenters["+t+"]"),a=E.getUniformLocation(L,"sphereColors["+t+"]"),e=E.getUniformLocation(L,"reflectiveColors["+t+"]"),o=E.getUniformLocation(L,"sphereSpecColors["+t+"]"),i=E.getUniformLocation(L,"sphereRoughness["+t+"]");E.uniform3f(_,r.x,r.y,r.z),E.uniform3f(a,r.r,r.g,r.b),E.uniform3f(e,r.rr,r.rg,r.rb),E.uniform3f(o,r.sr,r.sg,r.sb),E.uniform1f(i,r.roughness)}}(),mn(),vn(),function n(t){C=(t=.001*(t||0))-S,S=t,P+=1/C,50==(z+=1)&&(c.innerText=Math.floor(P/50),P=0,z=1);var r,a,e,o,i,p,m=d;if((u||g||b||y||x)&&(on(C),u=!1,m=!1),m&&(r=1/E.canvas.width,a=1/E.canvas.height,0,0,0,0,0,0,0,0,0,0,0,0,o=(1.5*Math.random()-.75)*r,i=(1.5*Math.random()-.75)*a,0,0,(p=new _(16))[0]=0,p[1]=0,p[2]=0,p[3]=0,p[4]=0,p[5]=0,p[6]=0,p[7]=0,p[8]=0,p[9]=0,p[10]=0,p[11]=0,p[12]=o,p[13]=i,p[14]=0,p[15]=0,function(n,t,r){n[0]=t[0]+r[0],n[1]=t[1]+r[1],n[2]=t[2]+r[2],n[3]=t[3]+r[3],n[4]=t[4]+r[4],n[5]=t[5]+r[5],n[6]=t[6]+r[6],n[7]=t[7]+r[7],n[8]=t[8]+r[8],n[9]=t[9]+r[9],n[10]=t[10]+r[10],n[11]=t[11]+r[11],n[12]=t[12]+r[12],n[13]=t[13]+r[13],n[14]=t[14]+r[14],n[15]=t[15]+r[15]}(e=p,en,e),E.uniformMatrix4fv(E.getUniformLocation(L,"invprojview"),!1,e)),E.uniform1i(I,m),E.uniform1f(k,Math.random()),d){var v=h?A:B;E.bindFramebuffer(E.DRAW_FRAMEBUFFER,v),E.bindTexture(E.TEXTURE_2D,h?N:T),E.clearColor(0,0,0,1),E.clear(E.COLOR_BUFFER_BIT),E.uniform1i(R,0),E.drawArrays(E.TRIANGLES,0,3),E.bindFramebuffer(E.READ_FRAMEBUFFER,v),E.bindFramebuffer(E.DRAW_FRAMEBUFFER,null),E.blitFramebuffer(0,0,E.canvas.width,E.canvas.height,0,0,E.canvas.width,E.canvas.height,E.COLOR_BUFFER_BIT,E.NEAREST),h=!h}else E.bindFramebuffer(E.DRAW_FRAMEBUFFER,null),E.drawArrays(E.TRIANGLES,0,3);requestAnimationFrame(n)}();for(var cn=0;cn<f.H.length;cn++)sn(cn,f.H);for(var hn=0;hn<f.Rm.length;hn++)fn(hn,f.Rm);function dn(n,t){switch(n){case"KeyW":g=t;break;case"KeyS":y=t;break;case"KeyA":b=t;break;case"KeyD":x=t}}window.addEventListener("resize",ln),document.addEventListener("mousedown",(function(n){n.target.closest(".controls")||2==n.button&&(document.pointerLockElement===n.target?document.exitPointerLock():n.target.requestPointerLock())})),document.addEventListener("mousemove",(function(n){var t;"canvas"===(null===(t=document.pointerLockElement)||void 0===t?void 0:t.id)&&(Q-=.0015*n.movementX,$-=.0015*n.movementY,u=!0)})),document.addEventListener("keydown",(function(n){return dn(n.code,!0)})),document.addEventListener("keyup",(function(n){return dn(n.code,!1)})),document.getElementById("enableTAA").addEventListener("input",(function(n){d=n.target.checked,ln()})),document.getElementById("enableGI").addEventListener("input",(function(n){M=n.target.checked,vn()})),document.getElementById("enableRefGI").addEventListener("input",(function(n){U=n.target.checked,vn()})),document.getElementById("indirectsamples").addEventListener("input",(function(n){F=n.target.value,vn()})),document.getElementById("directsamples").addEventListener("input",(function(n){G=n.target.value*n.target.value,vn()})),document.getElementById("reflectionbounces").addEventListener("input",(function(n){D=n.target.value,vn()})),document.getElementById("fov").addEventListener("input",(function(n){var t;t=n.target.value,j=t*a,on()})),document.getElementById("arealightsenable").addEventListener("input",(function(n){q=n.target.checked,mn()})),document.querySelectorAll(".attenuation").forEach((function(n){n.addEventListener("input",(function(n){"quadratic"===n.target.id?X=n.target.value:"linear"===n.target.id&&(H=n.target.value),vn()}))})),document.querySelectorAll(".light-enable").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].enabled=n.target.checked,mn()}))})),document.querySelectorAll(".light-brightness").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].brightness=n.target.value,mn()}))})),document.querySelectorAll(".light-spotsize").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].spotSize=1-n.target.value,mn()}))})),document.querySelectorAll(".light-spotintensity").forEach((function(n){n.addEventListener("input",(function(n){f.H[n.target.id].spotIntensity=n.target.value,mn()}))})),document.querySelectorAll(".light-color").forEach((function(n){n.addEventListener("input",(function(n){var t=f.H[n.target.id[0]];"r"===n.target.id[1]?t.r=n.target.value:"g"===n.target.id[1]?t.g=n.target.value:"b"===n.target.id[1]&&(t.b=n.target.value),mn()}))})),document.querySelectorAll(".light-size").forEach((function(n){n.addEventListener("input",(function(n){var t=f.H[n.target.id[0]];"x"===n.target.id[1]?t.sizeX=n.target.value:"y"===n.target.id[1]&&(t.sizeY=n.target.value),mn()}))})),document.querySelectorAll(".plane-enable").forEach((function(n){n.addEventListener("input",(function(n){f.Rm[n.target.id].enabled=n.target.checked,pn()}))})),document.getElementById("planebacksides").addEventListener("input",(function(n){O=n.target.checked,vn()})),document.getElementById("enablemirrorworld").addEventListener("input",(function(n){V=n.target.checked,vn()}))},424:(n,t,r)=>{r.d(t,{Z:()=>i});var _=r(81),a=r.n(_),e=r(645),o=r.n(e)()(a());o.push([n.id,"/* ----- COLORS ----- */\r\n:root {\r\n    --blue: #007bff;\r\n    /*--blue: #2e5bff;*/\r\n    --darkblue: #1374dc;\r\n    --blue-neon: #0dffff;\r\n    --teal: #11cdef;\r\n    --lightgreen: #00d774;\r\n    --orange: #fd7e14;\r\n    --darkorange: #e07217;\r\n    --gray1: #f4f5f7;\r\n    --gray2: #e2e6ea;\r\n    --gray3: #6c757d;\r\n    --gray4: #343a40;\r\n    --green: #28a745;\r\n    --green-dark: #1c8935;\r\n    --red: #dc3545;\r\n    --red-dark: #c42e3d;\r\n    --red-bright: #ff3355;\r\n    --red-light: #ff6384;\r\n    --purple-light: #5e72e4;\r\n    --purple: #6f42c1;\r\n    --purple-dark: rgb(112, 48, 160);\r\n}\r\n/*------------------------*/\r\n\r\nhtml {\r\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n}\r\n\r\nbody {\r\n    margin: 0;\r\n    padding: 0;\r\n    background-color: rgb(0, 0, 0);\r\n    overflow: hidden;\r\n}\r\n/*\r\ncanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n*/\r\n.controls {\r\n    position: absolute;\r\n    top: 1em;\r\n    right: 1em;\r\n    width: 250px;\r\n    padding: 0 0.2em 1em 1em;\r\n    background-color: rgb(255 255 255 / 60%);\r\n    border-radius: 15px;\r\n    max-height: 95%;\r\n    overflow-y: scroll;\r\n    overflow-x: hidden;\r\n}\r\n\r\n.controls::-webkit-scrollbar-track {\r\n    /*-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);*/\r\n \t/*border-radius: 10px;*/\r\n}\r\n.controls::-webkit-scrollbar {\r\n \twidth: 1em;\r\n}\r\n.controls::-webkit-scrollbar-thumb {\r\n    background-color: var(--blue);\r\n    border: 5px solid transparent;\r\n    border-radius: 15px;\r\n    background-clip: padding-box;\r\n}\r\n.controls::-webkit-scrollbar-thumb:hover {\r\n\tbackground-color: var(--darkblue);\r\n}\r\n\r\n.controls .section {\r\n    border-bottom: solid 1px rgb(255 255 255 / 60%);\r\n    margin: 1em 0 0 0;\r\n    padding: 0 0 1em;\r\n}\r\n\r\n.controls h3 {\r\n    padding: 0;\r\n    margin: 0 0 0.5em 0;\r\n    color: #005aff;\r\n    font-weight: 600;\r\n}\r\n\r\n.controls output {\r\n    color: #005aff;\r\n}\r\n\r\n.controls .deg-sign {\r\n    color: #005aff;\r\n}\r\n\r\n.controls .slider_container {\r\n    display: flex;\r\n    flex-direction: row;\r\n    align-items: center;\r\n}\r\n\r\ntable.sliders {\r\n    width: 100%;\r\n}\r\n\r\n.sliders input {\r\n    width: 100%;\r\n}\r\n\r\n#fps-container {\r\n    position: absolute;\r\n    top: 1em;\r\n    left: 1em;\r\n    color: white;\r\n}\r\n\r\n/* ----- Toggle switch ----- */\r\n/* The switch - the box around the slider */\r\n.switch {\r\n    position: relative;\r\n  }\r\n  /* Hide default HTML checkbox */\r\n  .switch input {\r\n    position: absolute;\r\n    opacity: 0;\r\n    width: 0;\r\n    height: 0;\r\n  }\r\n  /* The slider */\r\n  .slider {\r\n    border-radius: 10px;\r\n    position: relative;\r\n    display: inline-block;\r\n    cursor: pointer;\r\n    vertical-align: middle;\r\n    height: 15px;\r\n    width: 34px;\r\n    background-color: var(--gray2);\r\n    -webkit-transition: 0.4s;\r\n    transition: 0.4s;\r\n  }\r\n  .slider:before {\r\n    position: absolute;\r\n    content: \"\";\r\n    height: 11px;\r\n    width: 11px;\r\n    left: 3px;\r\n    bottom: 2px;\r\n    background-color: white;\r\n    -webkit-transition: 0.4s;\r\n    transition: 0.4s;\r\n    box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.21);\r\n    border-radius: 5px;\r\n  }\r\n  input:checked + .slider {\r\n    background-color: var(--blue);\r\n  }\r\n  input:checked + .slider.del {\r\n    background-color: var(--red-bright);\r\n  }\r\n  input:checked + .slider:before {\r\n    transform: translateX(17px);\r\n  }\r\n  /* ----------------------- */",""]);const i=o},645:n=>{n.exports=function(n){var t=[];return t.toString=function(){return this.map((function(t){var r="",_=void 0!==t[5];return t[4]&&(r+="@supports (".concat(t[4],") {")),t[2]&&(r+="@media ".concat(t[2]," {")),_&&(r+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),r+=n(t),_&&(r+="}"),t[2]&&(r+="}"),t[4]&&(r+="}"),r})).join("")},t.i=function(n,r,_,a,e){"string"==typeof n&&(n=[[null,n,void 0]]);var o={};if(_)for(var i=0;i<this.length;i++){var p=this[i][0];null!=p&&(o[p]=!0)}for(var m=0;m<n.length;m++){var v=[].concat(n[m]);_&&o[v[0]]||(void 0!==e&&(void 0===v[5]||(v[1]="@layer".concat(v[5].length>0?" ".concat(v[5]):""," {").concat(v[1],"}")),v[5]=e),r&&(v[2]?(v[1]="@media ".concat(v[2]," {").concat(v[1],"}"),v[2]=r):v[2]=r),a&&(v[4]?(v[1]="@supports (".concat(v[4],") {").concat(v[1],"}"),v[4]=a):v[4]="".concat(a)),t.push(v))}},t}},81:n=>{n.exports=function(n){return n[1]}},548:(n,t,r)=>{var _=r(379),a=r.n(_),e=r(795),o=r.n(e),i=r(569),p=r.n(i),m=r(565),v=r.n(m),l=r(216),s=r.n(l),f=r(589),c=r.n(f),h=r(424),d={};d.styleTagTransform=c(),d.setAttributes=v(),d.insert=p().bind(null,"head"),d.domAPI=o(),d.insertStyleElement=s(),a()(h.Z,d),h.Z&&h.Z.locals&&h.Z.locals},379:n=>{var t=[];function r(n){for(var r=-1,_=0;_<t.length;_++)if(t[_].identifier===n){r=_;break}return r}function _(n,_){for(var e={},o=[],i=0;i<n.length;i++){var p=n[i],m=_.base?p[0]+_.base:p[0],v=e[m]||0,l="".concat(m," ").concat(v);e[m]=v+1;var s=r(l),f={css:p[1],media:p[2],sourceMap:p[3],supports:p[4],layer:p[5]};if(-1!==s)t[s].references++,t[s].updater(f);else{var c=a(f,_);_.byIndex=i,t.splice(i,0,{identifier:l,updater:c,references:1})}o.push(l)}return o}function a(n,t){var r=t.domAPI(t);return r.update(n),function(t){if(t){if(t.css===n.css&&t.media===n.media&&t.sourceMap===n.sourceMap&&t.supports===n.supports&&t.layer===n.layer)return;r.update(n=t)}else r.remove()}}n.exports=function(n,a){var e=_(n=n||[],a=a||{});return function(n){n=n||[];for(var o=0;o<e.length;o++){var i=r(e[o]);t[i].references--}for(var p=_(n,a),m=0;m<e.length;m++){var v=r(e[m]);0===t[v].references&&(t[v].updater(),t.splice(v,1))}e=p}}},569:n=>{var t={};n.exports=function(n,r){var _=function(n){if(void 0===t[n]){var r=document.querySelector(n);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(n){r=null}t[n]=r}return t[n]}(n);if(!_)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");_.appendChild(r)}},216:n=>{n.exports=function(n){var t=document.createElement("style");return n.setAttributes(t,n.attributes),n.insert(t,n.options),t}},565:(n,t,r)=>{n.exports=function(n){var t=r.nc;t&&n.setAttribute("nonce",t)}},795:n=>{n.exports=function(n){var t=n.insertStyleElement(n);return{update:function(r){!function(n,t,r){var _="";r.supports&&(_+="@supports (".concat(r.supports,") {")),r.media&&(_+="@media ".concat(r.media," {"));var a=void 0!==r.layer;a&&(_+="@layer".concat(r.layer.length>0?" ".concat(r.layer):""," {")),_+=r.css,a&&(_+="}"),r.media&&(_+="}"),r.supports&&(_+="}");var e=r.sourceMap;e&&"undefined"!=typeof btoa&&(_+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(e))))," */")),t.styleTagTransform(_,n,t.options)}(t,n,r)},remove:function(){!function(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n)}(t)}}}},589:n=>{n.exports=function(n,t){if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}},574:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nfloat randomIncrement;\nuniform float randomseed;\nuniform highp int numLights;\nuniform vec3 lightPos[2];\nuniform vec2 lightSize[2];\nuniform vec3 lightBrightness[2];\nuniform vec2 lightSpot[2];\nuniform highp int shadowSamples;\nuniform float shadowDim;\nuniform vec2 attenuationFactor;\nuniform highp int numSpheres;\nuniform vec3 sphereCenters[4];\nuniform vec3 sphereColors[4];\nuniform vec3 reflectiveColors[4];\nuniform vec3 sphereSpecColors[4];\nuniform float sphereRoughness[4];\nuniform highp int numPlanes;\nuniform float planeOffsets[6];\nuniform vec3 planeNormals[6];\nuniform vec3 planeColors[6];\nuniform float planeSpecular[6];\nuniform float planeRoughness[6];\nuniform highp int rayBounces;\nuniform vec3 ambientLight;\nuniform bool enableGI;\nuniform bool enableRefGI;\nuniform highp int indirectSamples;\nuniform bool enablePlaneBacksides;\nuniform bool enablePlaneMirrors;\nuniform bool enableTAA;\nuniform sampler2D u_texture;\nin vec3 origin;\nin vec3 ray;\nin vec2 texCoord;\nout lowp vec4 fragColor;\nvoid main ()\n{\n  float roughness_1;\n  vec3 reflectiveColor_2;\n  vec3 specularColor_3;\n  vec3 diffuseColor_4;\n  lowp vec3 pixelColor_5;\n  vec3 tmpvar_6;\n  tmpvar_6 = normalize(ray);\n  randomIncrement = randomseed;\n  vec3 ray_origin_7;\n  ray_origin_7 = origin;\n  vec3 ray_direction_8;\n  ray_direction_8 = tmpvar_6;\n  float t_hit_9;\n  t_hit_9 = sqrt(dot (ray, ray));\n  vec3 position_10;\n  vec3 normal_11;\n  vec3 diffuseColor_12;\n  diffuseColor_12 = diffuseColor_4;\n  vec3 specularColor_13;\n  specularColor_13 = specularColor_3;\n  vec3 reflectiveColor_14;\n  reflectiveColor_14 = reflectiveColor_2;\n  float roughness_15;\n  roughness_15 = roughness_1;\n  bool intersectLight_16;\n  intersectLight_16 = bool(1);\n  highp int idx_19;\n  highp int intersected_20;\n  intersected_20 = 0;\n  idx_19 = 0;\n  for (highp int i_18 = 0; i_18 < numSpheres; i_18++) {\n    float t_hit_21;\n    t_hit_21 = t_hit_9;\n    bool tmpvar_22;\n    vec3 tmpvar_23;\n    tmpvar_23 = (sphereCenters[i_18] - ray_origin_7);\n    float tmpvar_24;\n    tmpvar_24 = dot (tmpvar_23, ray_direction_8);\n    if ((tmpvar_24 < 0.0)) {\n      tmpvar_22 = bool(0);\n    } else {\n      float tmpvar_25;\n      tmpvar_25 = (dot (tmpvar_23, tmpvar_23) - (tmpvar_24 * tmpvar_24));\n      if ((tmpvar_25 > 0.64)) {\n        tmpvar_22 = bool(0);\n      } else {\n        float tmpvar_26;\n        tmpvar_26 = sqrt((0.64 - tmpvar_25));\n        float tmpvar_27;\n        tmpvar_27 = (tmpvar_24 - tmpvar_26);\n        float tmpvar_28;\n        tmpvar_28 = (tmpvar_24 + tmpvar_26);\n        float tmpvar_29;\n        if ((tmpvar_27 < 0.0)) {\n          tmpvar_29 = tmpvar_28;\n        } else {\n          tmpvar_29 = tmpvar_27;\n        };\n        if (((tmpvar_29 < t_hit_9) && (tmpvar_29 > 0.0))) {\n          t_hit_21 = tmpvar_29;\n          tmpvar_22 = bool(1);\n        } else {\n          tmpvar_22 = bool(0);\n        };\n      };\n    };\n    t_hit_9 = t_hit_21;\n    if (tmpvar_22) {\n      idx_19 = i_18;\n      intersected_20 = 1;\n    };\n  };\n  for (highp int i_17 = 0; i_17 < numPlanes; i_17++) {\n    vec3 tmpvar_30;\n    tmpvar_30 = planeNormals[i_17];\n    bool tmpvar_31;\n    if (enablePlaneBacksides) {\n      tmpvar_31 = bool(1);\n    } else {\n      tmpvar_31 = (dot (ray_direction_8, tmpvar_30) < 0.0);\n    };\n    if (tmpvar_31) {\n      float t_hit_32;\n      t_hit_32 = t_hit_9;\n      bool tmpvar_33;\n      tmpvar_33 = bool(1);\n      bool tmpvar_34;\n      vec3 tmpvar_35;\n      tmpvar_35 = (tmpvar_30 * planeOffsets[i_17]);\n      float tmpvar_36;\n      tmpvar_36 = (((\n        (tmpvar_35.x + tmpvar_35.y)\n       + tmpvar_35.z) - dot (tmpvar_30, ray_origin_7)) / dot (tmpvar_30, ray_direction_8));\n      if (((tmpvar_36 < t_hit_9) && (tmpvar_36 > 0.0))) {\n        t_hit_32 = tmpvar_36;\n        tmpvar_34 = bool(1);\n        tmpvar_33 = bool(0);\n      };\n      if (tmpvar_33) {\n        tmpvar_34 = bool(0);\n        tmpvar_33 = bool(0);\n      };\n      t_hit_9 = t_hit_32;\n      if (tmpvar_34) {\n        normal_11 = tmpvar_30;\n        idx_19 = i_17;\n        intersected_20 = 2;\n      };\n    };\n  };\n  intersectLight_16 = bool(0);\n  for (highp int i_37 = 0; i_37 < numLights; i_37++) {\n    bool tmp_38;\n    vec3 tmpvar_39;\n    tmpvar_39 = lightPos[i_37];\n    vec2 tmpvar_40;\n    tmpvar_40 = lightSize[i_37];\n    tmp_38 = bool(0);\n    if (((tmpvar_40.x > 0.0) && (tmpvar_40.y > 0.0))) {\n      float t_hit_41;\n      t_hit_41 = t_hit_9;\n      bool tmpvar_42;\n      tmpvar_42 = bool(1);\n      bool tmpvar_43;\n      vec3 tmpvar_44;\n      tmpvar_44 = (vec3(0.0, 1.0, 0.0) * tmpvar_39.y);\n      float tmpvar_45;\n      tmpvar_45 = (((\n        (tmpvar_44.x + tmpvar_44.y)\n       + tmpvar_44.z) - ray_origin_7.y) / ray_direction_8.y);\n      if (((tmpvar_45 < t_hit_9) && (tmpvar_45 > 0.0))) {\n        vec3 tmpvar_46;\n        tmpvar_46 = (ray_origin_7 + (ray_direction_8 * tmpvar_45));\n        if ((((tmpvar_40.x + tmpvar_40.y) == 0.0) || ((\n          ((tmpvar_46.x < (tmpvar_39.x + (tmpvar_40.x * 0.5))) && (tmpvar_46.x > (tmpvar_39.x - (tmpvar_40.x * 0.5))))\n         && \n          (tmpvar_46.z < (tmpvar_39.z + (tmpvar_40.y * 0.5)))\n        ) && (tmpvar_46.z > \n          (tmpvar_39.z - (tmpvar_40.y * 0.5))\n        )))) {\n          t_hit_41 = tmpvar_45;\n          tmpvar_43 = bool(1);\n          tmpvar_42 = bool(0);\n        };\n      };\n      if (tmpvar_42) {\n        tmpvar_43 = bool(0);\n        tmpvar_42 = bool(0);\n      };\n      t_hit_9 = t_hit_41;\n      tmp_38 = tmpvar_43;\n    } else {\n      float t_hit_47;\n      t_hit_47 = t_hit_9;\n      bool tmpvar_48;\n      vec3 tmpvar_49;\n      tmpvar_49 = (tmpvar_39 - ray_origin_7);\n      float tmpvar_50;\n      tmpvar_50 = dot (tmpvar_49, ray_direction_8);\n      if ((tmpvar_50 < 0.0)) {\n        tmpvar_48 = bool(0);\n      } else {\n        float tmpvar_51;\n        tmpvar_51 = (dot (tmpvar_49, tmpvar_49) - (tmpvar_50 * tmpvar_50));\n        if ((tmpvar_51 > 0.01)) {\n          tmpvar_48 = bool(0);\n        } else {\n          float tmpvar_52;\n          tmpvar_52 = sqrt((0.01 - tmpvar_51));\n          float tmpvar_53;\n          tmpvar_53 = (tmpvar_50 - tmpvar_52);\n          float tmpvar_54;\n          tmpvar_54 = (tmpvar_50 + tmpvar_52);\n          float tmpvar_55;\n          if ((tmpvar_53 < 0.0)) {\n            tmpvar_55 = tmpvar_54;\n          } else {\n            tmpvar_55 = tmpvar_53;\n          };\n          if (((tmpvar_55 < t_hit_9) && (tmpvar_55 > 0.0))) {\n            t_hit_47 = tmpvar_55;\n            tmpvar_48 = bool(1);\n          } else {\n            tmpvar_48 = bool(0);\n          };\n        };\n      };\n      t_hit_9 = t_hit_47;\n      tmp_38 = tmpvar_48;\n    };\n    if (tmp_38) {\n      idx_19 = i_37;\n      intersected_20 = 3;\n    };\n  };\n  position_10 = (origin + (tmpvar_6 * t_hit_9));\n  if ((intersected_20 == 1)) {\n    diffuseColor_12 = sphereColors[idx_19];\n    specularColor_13 = sphereSpecColors[idx_19];\n    reflectiveColor_14 = reflectiveColors[idx_19];\n    roughness_15 = sphereRoughness[idx_19];\n    vec3 tmpvar_56;\n    tmpvar_56 = normalize((position_10 - sphereCenters[idx_19]));\n    normal_11 = tmpvar_56;\n    float tmpvar_57;\n    tmpvar_57 = dot (tmpvar_56, -(tmpvar_6));\n    if ((tmpvar_57 < 0.0)) {\n      normal_11 = -(tmpvar_56);\n    };\n  } else {\n    if ((intersected_20 == 2)) {\n      if (!(enablePlaneMirrors)) {\n        diffuseColor_12 = planeColors[idx_19];\n        specularColor_13 = vec3(planeSpecular[idx_19]);\n        reflectiveColor_14 = vec3(0.0, 0.0, 0.0);\n        roughness_15 = planeRoughness[idx_19];\n      } else {\n        diffuseColor_12 = (planeColors[idx_19] * 0.01);\n        specularColor_13 = vec3(0.0, 0.0, 0.0);\n        reflectiveColor_14 = planeColors[idx_19];\n        roughness_15 = 1.0;\n      };\n      float tmpvar_58;\n      tmpvar_58 = dot (normal_11, -(tmpvar_6));\n      if ((tmpvar_58 < 0.0)) {\n        normal_11 = -(normal_11);\n      };\n    } else {\n      if ((intersected_20 == 3)) {\n        float spot_falloff_59;\n        spot_falloff_59 = 1.0;\n        vec2 tmpvar_60;\n        tmpvar_60 = lightSpot[idx_19];\n        if ((tmpvar_60.x > 0.0)) {\n          float tmpvar_61;\n          if ((tmpvar_6.y > tmpvar_60.x)) {\n            tmpvar_61 = pow (tmpvar_6.y, tmpvar_60.y);\n          } else {\n            tmpvar_61 = 0.0;\n          };\n          spot_falloff_59 = tmpvar_61;\n        };\n        diffuseColor_12 = ((spot_falloff_59 * lightBrightness[idx_19]) * 0.2);\n        intersectLight_16 = bool(1);\n      };\n    };\n  };\n  diffuseColor_4 = diffuseColor_12;\n  specularColor_3 = specularColor_13;\n  reflectiveColor_2 = reflectiveColor_14;\n  roughness_1 = roughness_15;\n  if (intersectLight_16) {\n    lowp vec4 tmpvar_62;\n    if (enableTAA) {\n      vec4 tmpvar_63;\n      tmpvar_63.w = 1.0;\n      tmpvar_63.xyz = diffuseColor_12;\n      tmpvar_62 = ((0.1 * min (tmpvar_63, 1.0)) + (0.9 * texture (u_texture, texCoord)));\n    } else {\n      lowp vec4 tmpvar_64;\n      tmpvar_64.w = 1.0;\n      tmpvar_64.xyz = diffuseColor_12;\n      tmpvar_62 = tmpvar_64;\n    };\n    fragColor = tmpvar_62;\n    return;\n  };\n  if (!(enableGI)) {\n    pixelColor_5 = (pixelColor_5 + (ambientLight * diffuseColor_12));\n  };\n  vec3 P_65;\n  P_65 = position_10;\n  vec3 V_66;\n  V_66 = tmpvar_6;\n  vec3 N_67;\n  N_67 = normal_11;\n  vec3 diffuseColor_68;\n  diffuseColor_68 = diffuseColor_12;\n  vec3 specularColor_69;\n  specularColor_69 = specularColor_13;\n  vec3 illuminationColor_71;\n  for (highp int i_70 = 0; i_70 < numLights; i_70++) {\n    highp int k_72;\n    bool inShade_73;\n    highp int areaShadowSamples_74;\n    highp int testSamples_75;\n    vec3 light_sum_76;\n    vec2 lightSpot_77;\n    vec2 lightSize_78;\n    vec3 lightBrightness_79;\n    vec3 lightPos_80;\n    lightPos_80 = lightPos[i_70];\n    lightBrightness_79 = lightBrightness[i_70];\n    vec2 tmpvar_81;\n    tmpvar_81 = lightSize[i_70];\n    lightSize_78 = tmpvar_81;\n    lightSpot_77 = lightSpot[i_70];\n    bool tmpvar_82;\n    tmpvar_82 = ((tmpvar_81.x > 0.0) && (tmpvar_81.y > 0.0));\n    highp int tmpvar_83;\n    if (tmpvar_82) {\n      tmpvar_83 = 5;\n    } else {\n      tmpvar_83 = 1;\n    };\n    testSamples_75 = tmpvar_83;\n    areaShadowSamples_74 = 0;\n    inShade_73 = bool(0);\n    k_72 = 0;\n    while (true) {\n      vec3 testPos_84;\n      if ((k_72 >= testSamples_75)) {\n        break;\n      };\n      if (inShade_73) {\n        break;\n      };\n      testPos_84 = lightPos_80;\n      if ((k_72 == 1)) {\n        testPos_84.x = (lightPos_80.x - (lightSize_78.x * 0.5));\n        testPos_84.z = (lightPos_80.z - (lightSize_78.y * 0.5));\n      } else {\n        if ((k_72 == 2)) {\n          testPos_84.x = (testPos_84.x + (lightSize_78.x * 0.5));\n          testPos_84.z = (testPos_84.z + (lightSize_78.y * 0.5));\n        } else {\n          if ((k_72 == 3)) {\n            testPos_84.x = (testPos_84.x + (lightSize_78.x * 0.5));\n            testPos_84.z = (testPos_84.z - (lightSize_78.y * 0.5));\n          } else {\n            if ((k_72 == 4)) {\n              testPos_84.x = (testPos_84.x - (lightSize_78.x * 0.5));\n              testPos_84.z = (testPos_84.z + (lightSize_78.y * 0.5));\n            };\n          };\n        };\n      };\n      vec3 L_85;\n      vec3 incidentIntensity_86;\n      float falloff_87;\n      L_85 = (testPos_84 - P_65);\n      float tmpvar_88;\n      tmpvar_88 = sqrt(dot (L_85, L_85));\n      float tmpvar_89;\n      tmpvar_89 = (1.0/(((attenuationFactor.x * \n        (tmpvar_88 * tmpvar_88)\n      ) + (attenuationFactor.y * tmpvar_88))));\n      vec3 tmpvar_90;\n      tmpvar_90 = normalize(L_85);\n      L_85 = tmpvar_90;\n      falloff_87 = 1.0;\n      if ((lightSpot_77.x > 0.0)) {\n        float tmpvar_91;\n        if ((tmpvar_90.y > lightSpot_77.x)) {\n          tmpvar_91 = pow (tmpvar_90.y, lightSpot_77.y);\n        } else {\n          tmpvar_91 = 0.0;\n        };\n        falloff_87 = tmpvar_91;\n      };\n      incidentIntensity_86 = ((lightBrightness_79 * tmpvar_89) * falloff_87);\n      float tmpvar_92;\n      tmpvar_92 = dot (N_67, tmpvar_90);\n      if (((tmpvar_92 > 0.0) && ((\n        (incidentIntensity_86.x + incidentIntensity_86.y)\n       + incidentIntensity_86.z) > 0.01))) {\n        vec3 ray_origin_93;\n        ray_origin_93 = P_65;\n        vec3 ray_direction_94;\n        ray_direction_94 = tmpvar_90;\n        float t_hit_95;\n        t_hit_95 = tmpvar_88;\n        bool tmpvar_96;\n        tmpvar_96 = bool(0);\n        highp int i_97;\n        highp int i_98;\n        i_98 = 0;\n        while (true) {\n          if ((i_98 >= numSpheres)) {\n            break;\n          };\n          float t_hit_99;\n          t_hit_99 = t_hit_95;\n          bool tmpvar_100;\n          vec3 tmpvar_101;\n          tmpvar_101 = (sphereCenters[i_98] - ray_origin_93);\n          float tmpvar_102;\n          tmpvar_102 = dot (tmpvar_101, ray_direction_94);\n          if ((tmpvar_102 < 0.0)) {\n            tmpvar_100 = bool(0);\n          } else {\n            float tmpvar_103;\n            tmpvar_103 = (dot (tmpvar_101, tmpvar_101) - (tmpvar_102 * tmpvar_102));\n            if ((tmpvar_103 > 0.64)) {\n              tmpvar_100 = bool(0);\n            } else {\n              float tmpvar_104;\n              tmpvar_104 = sqrt((0.64 - tmpvar_103));\n              float tmpvar_105;\n              tmpvar_105 = (tmpvar_102 - tmpvar_104);\n              float tmpvar_106;\n              tmpvar_106 = (tmpvar_102 + tmpvar_104);\n              float tmpvar_107;\n              if ((tmpvar_105 < 0.001)) {\n                tmpvar_107 = tmpvar_106;\n              } else {\n                tmpvar_107 = tmpvar_105;\n              };\n              if (((tmpvar_107 < t_hit_95) && (tmpvar_107 > 0.001))) {\n                t_hit_99 = tmpvar_107;\n                tmpvar_100 = bool(1);\n              } else {\n                tmpvar_100 = bool(0);\n              };\n            };\n          };\n          t_hit_95 = t_hit_99;\n          if (tmpvar_100) {\n            tmpvar_96 = bool(1);\n            break;\n          };\n          i_98++;\n        };\n        if (!(tmpvar_96)) {\n          i_97 = 0;\n          while (true) {\n            if ((i_97 >= numPlanes)) {\n              break;\n            };\n            vec3 normal_108;\n            normal_108 = planeNormals[i_97];\n            float t_hit_109;\n            t_hit_109 = t_hit_95;\n            bool tmpvar_110;\n            tmpvar_110 = bool(1);\n            bool tmpvar_111;\n            vec3 tmpvar_112;\n            tmpvar_112 = (normal_108 * planeOffsets[i_97]);\n            float tmpvar_113;\n            tmpvar_113 = (((\n              (tmpvar_112.x + tmpvar_112.y)\n             + tmpvar_112.z) - dot (normal_108, ray_origin_93)) / dot (normal_108, ray_direction_94));\n            if (((tmpvar_113 < t_hit_95) && (tmpvar_113 > 0.001))) {\n              t_hit_109 = tmpvar_113;\n              tmpvar_111 = bool(1);\n              tmpvar_110 = bool(0);\n            };\n            if (tmpvar_110) {\n              tmpvar_111 = bool(0);\n              tmpvar_110 = bool(0);\n            };\n            t_hit_95 = t_hit_109;\n            if (tmpvar_111) {\n              tmpvar_96 = bool(1);\n              break;\n            };\n            i_97++;\n          };\n          if (!(tmpvar_96)) {\n            tmpvar_96 = bool(1);\n          };\n        };\n        float tmpvar_114;\n        tmpvar_114 = abs((t_hit_95 - tmpvar_88));\n        if ((tmpvar_114 < 0.001)) {\n          vec3 I_115;\n          I_115 = -(tmpvar_90);\n          light_sum_76 = (light_sum_76 + (incidentIntensity_86 * (\n            (diffuseColor_68 * dot (N_67, tmpvar_90))\n           + \n            (specularColor_69 * pow (max (0.0, dot (\n              (I_115 - (2.0 * (dot (N_67, I_115) * N_67)))\n            , \n              -(V_66)\n            )), 128.0))\n          )));\n        } else {\n          inShade_73 = bool(1);\n        };\n      } else {\n        inShade_73 = bool(1);\n      };\n      areaShadowSamples_74++;\n      k_72++;\n    };\n    if ((tmpvar_82 && inShade_73)) {\n      highp int k_116;\n      areaShadowSamples_74 = shadowSamples;\n      light_sum_76 = vec3(0.0, 0.0, 0.0);\n      k_116 = 0;\n      while (true) {\n        vec3 incidentIntensity_117;\n        if ((k_116 >= areaShadowSamples_74)) {\n          break;\n        };\n        float sample_i_118;\n        sample_i_118 = float(k_116);\n        vec3 L_119;\n        float falloff_120;\n        float tmpvar_121;\n        tmpvar_121 = (1.0/(shadowDim));\n        randomIncrement += 0.02;\n        float tmpvar_122;\n        tmpvar_122 = ((lightSize_78.x * tmpvar_121) * ((float(mod (sample_i_118, shadowDim))) + fract(\n          (cos(dot ((P_65.xy + randomIncrement), vec2(23.14069, 2.665144))) * 12345.68)\n        )));\n        randomIncrement += 0.02;\n        vec3 tmpvar_123;\n        tmpvar_123.x = ((lightPos_80.x - (lightSize_78.x * 0.5)) + tmpvar_122);\n        tmpvar_123.y = lightPos_80.y;\n        tmpvar_123.z = ((lightPos_80.z - (lightSize_78.y * 0.5)) + ((lightSize_78.y * tmpvar_121) * (\n          floor((sample_i_118 * tmpvar_121))\n         + \n          fract((cos(dot (\n            (P_65.yx + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n        )));\n        L_119 = (tmpvar_123 - P_65);\n        float tmpvar_124;\n        tmpvar_124 = sqrt(dot (L_119, L_119));\n        float tmpvar_125;\n        tmpvar_125 = (1.0/(((attenuationFactor.x * \n          (tmpvar_124 * tmpvar_124)\n        ) + (attenuationFactor.y * tmpvar_124))));\n        vec3 tmpvar_126;\n        tmpvar_126 = normalize(L_119);\n        L_119 = tmpvar_126;\n        falloff_120 = 1.0;\n        if ((lightSpot_77.x > 0.0)) {\n          float tmpvar_127;\n          if ((tmpvar_126.y > lightSpot_77.x)) {\n            tmpvar_127 = pow (tmpvar_126.y, lightSpot_77.y);\n          } else {\n            tmpvar_127 = 0.0;\n          };\n          falloff_120 = tmpvar_127;\n        };\n        incidentIntensity_117 = ((lightBrightness_79 * tmpvar_125) * falloff_120);\n        vec3 ray_origin_128;\n        ray_origin_128 = P_65;\n        vec3 ray_direction_129;\n        ray_direction_129 = tmpvar_126;\n        float t_hit_130;\n        t_hit_130 = tmpvar_124;\n        bool tmpvar_131;\n        bool tmpvar_132;\n        tmpvar_132 = bool(0);\n        highp int i_133;\n        highp int i_134;\n        i_134 = 0;\n        while (true) {\n          if ((i_134 >= numSpheres)) {\n            break;\n          };\n          float t_hit_135;\n          t_hit_135 = t_hit_130;\n          bool tmpvar_136;\n          vec3 tmpvar_137;\n          tmpvar_137 = (sphereCenters[i_134] - ray_origin_128);\n          float tmpvar_138;\n          tmpvar_138 = dot (tmpvar_137, ray_direction_129);\n          if ((tmpvar_138 < 0.0)) {\n            tmpvar_136 = bool(0);\n          } else {\n            float tmpvar_139;\n            tmpvar_139 = (dot (tmpvar_137, tmpvar_137) - (tmpvar_138 * tmpvar_138));\n            if ((tmpvar_139 > 0.64)) {\n              tmpvar_136 = bool(0);\n            } else {\n              float tmpvar_140;\n              tmpvar_140 = sqrt((0.64 - tmpvar_139));\n              float tmpvar_141;\n              tmpvar_141 = (tmpvar_138 - tmpvar_140);\n              float tmpvar_142;\n              tmpvar_142 = (tmpvar_138 + tmpvar_140);\n              float tmpvar_143;\n              if ((tmpvar_141 < 0.001)) {\n                tmpvar_143 = tmpvar_142;\n              } else {\n                tmpvar_143 = tmpvar_141;\n              };\n              if (((tmpvar_143 < t_hit_130) && (tmpvar_143 > 0.001))) {\n                t_hit_135 = tmpvar_143;\n                tmpvar_136 = bool(1);\n              } else {\n                tmpvar_136 = bool(0);\n              };\n            };\n          };\n          t_hit_130 = t_hit_135;\n          if (tmpvar_136) {\n            tmpvar_131 = bool(1);\n            tmpvar_132 = bool(1);\n            break;\n          };\n          i_134++;\n        };\n        if (!(tmpvar_132)) {\n          i_133 = 0;\n          while (true) {\n            if ((i_133 >= numPlanes)) {\n              break;\n            };\n            vec3 normal_144;\n            normal_144 = planeNormals[i_133];\n            float t_hit_145;\n            t_hit_145 = t_hit_130;\n            bool tmpvar_146;\n            tmpvar_146 = bool(1);\n            bool tmpvar_147;\n            vec3 tmpvar_148;\n            tmpvar_148 = (normal_144 * planeOffsets[i_133]);\n            float tmpvar_149;\n            tmpvar_149 = (((\n              (tmpvar_148.x + tmpvar_148.y)\n             + tmpvar_148.z) - dot (normal_144, ray_origin_128)) / dot (normal_144, ray_direction_129));\n            if (((tmpvar_149 < t_hit_130) && (tmpvar_149 > 0.001))) {\n              t_hit_145 = tmpvar_149;\n              tmpvar_147 = bool(1);\n              tmpvar_146 = bool(0);\n            };\n            if (tmpvar_146) {\n              tmpvar_147 = bool(0);\n              tmpvar_146 = bool(0);\n            };\n            t_hit_130 = t_hit_145;\n            if (tmpvar_147) {\n              tmpvar_131 = bool(1);\n              tmpvar_132 = bool(1);\n              break;\n            };\n            i_133++;\n          };\n          if (!(tmpvar_132)) {\n            tmpvar_131 = bool(0);\n            tmpvar_132 = bool(1);\n          };\n        };\n        if (!(tmpvar_131)) {\n          vec3 I_150;\n          I_150 = -(tmpvar_126);\n          light_sum_76 = (light_sum_76 + (incidentIntensity_117 * (\n            (diffuseColor_68 * dot (N_67, tmpvar_126))\n           + \n            (specularColor_69 * pow (max (0.0, dot (\n              (I_150 - (2.0 * (dot (N_67, I_150) * N_67)))\n            , \n              -(V_66)\n            )), 128.0))\n          )));\n        };\n        k_116++;\n      };\n    };\n    illuminationColor_71 = (illuminationColor_71 + (light_sum_76 / float(areaShadowSamples_74)));\n  };\n  pixelColor_5 = (pixelColor_5 + (roughness_15 * illuminationColor_71));\n  if ((((enableGI && \n    (diffuseColor_12.x > 0.0)\n  ) && (diffuseColor_12.y > 0.0)) && (diffuseColor_12.z > 0.0))) {\n    if ((roughness_15 < 1.0)) {\n      vec3 P_151;\n      P_151 = position_10;\n      vec3 V_152;\n      V_152 = tmpvar_6;\n      vec3 N_153;\n      N_153 = normal_11;\n      float G1_alpha_155;\n      float VNDF_alpha_156;\n      mat3 basis_157;\n      vec3 indirect_sampling_sum_158;\n      mat3 ret_159;\n      ret_159[1] = normal_11;\n      if ((normal_11.z < -0.9998057)) {\n        ret_159[0] = vec3(0.0, -1.0, 0.0);\n        ret_159[2] = vec3(-1.0, 0.0, 0.0);\n      } else {\n        float tmpvar_160;\n        tmpvar_160 = (1.0/((1.0 + normal_11.z)));\n        float tmpvar_161;\n        tmpvar_161 = ((-(normal_11.x) * normal_11.y) * tmpvar_160);\n        vec3 tmpvar_162;\n        tmpvar_162.x = (1.0 - ((normal_11.x * normal_11.x) * tmpvar_160));\n        tmpvar_162.y = tmpvar_161;\n        tmpvar_162.z = -(normal_11.x);\n        ret_159[0] = tmpvar_162;\n        vec3 tmpvar_163;\n        tmpvar_163.x = tmpvar_161;\n        tmpvar_163.y = (1.0 - ((normal_11.y * normal_11.y) * tmpvar_160));\n        tmpvar_163.z = -(normal_11.y);\n        ret_159[2] = tmpvar_163;\n      };\n      basis_157 = ret_159;\n      VNDF_alpha_156 = (roughness_15 * roughness_15);\n      float tmpvar_164;\n      tmpvar_164 = max (roughness_15, 0.02);\n      float tmpvar_165;\n      tmpvar_165 = (tmpvar_164 * tmpvar_164);\n      G1_alpha_155 = (tmpvar_165 * tmpvar_165);\n      for (highp int i_154 = 0; i_154 < indirectSamples; i_154++) {\n        float roughness2_166;\n        vec3 reflective2_167;\n        vec3 specular2_168;\n        vec3 diffuse2_169;\n        float G1_NoR_170;\n        randomIncrement += 0.02;\n        float tmpvar_171;\n        tmpvar_171 = fract((cos(\n          dot ((P_151.xz + randomIncrement), vec2(23.14069, 2.665144))\n        ) * 12345.68));\n        randomIncrement += 0.02;\n        float tmpvar_172;\n        tmpvar_172 = fract((cos(\n          dot ((P_151.xy + randomIncrement), vec2(23.14069, 2.665144))\n        ) * 12345.68));\n        float t2_173;\n        vec3 tmpvar_174;\n        tmpvar_174.x = dot (V_152, basis_157[0]);\n        tmpvar_174.y = dot (V_152, basis_157[2]);\n        tmpvar_174.z = dot (V_152, basis_157[1]);\n        vec3 tmpvar_175;\n        tmpvar_175 = -(tmpvar_174);\n        vec3 tmpvar_176;\n        tmpvar_176.xy = (vec2(VNDF_alpha_156) * tmpvar_175.xy);\n        tmpvar_176.z = tmpvar_175.z;\n        vec3 tmpvar_177;\n        tmpvar_177 = normalize(tmpvar_176);\n        float tmpvar_178;\n        tmpvar_178 = ((tmpvar_177.x * tmpvar_177.x) + (tmpvar_177.y * tmpvar_177.y));\n        vec3 tmpvar_179;\n        if ((tmpvar_178 > 0.0)) {\n          vec3 tmpvar_180;\n          tmpvar_180.z = 0.0;\n          tmpvar_180.x = -(tmpvar_177.y);\n          tmpvar_180.y = tmpvar_177.x;\n          tmpvar_179 = (tmpvar_180 * inversesqrt(tmpvar_178));\n        } else {\n          tmpvar_179 = vec3(1.0, 0.0, 0.0);\n        };\n        float tmpvar_181;\n        tmpvar_181 = sqrt(tmpvar_171);\n        float tmpvar_182;\n        tmpvar_182 = (6.283186 * tmpvar_172);\n        float tmpvar_183;\n        tmpvar_183 = (tmpvar_181 * cos(tmpvar_182));\n        float tmpvar_184;\n        tmpvar_184 = (0.5 * (1.0 + tmpvar_177.z));\n        t2_173 = (((1.0 - tmpvar_184) * sqrt(\n          (1.0 - (tmpvar_183 * tmpvar_183))\n        )) + (tmpvar_184 * (tmpvar_181 * \n          sin(tmpvar_182)\n        )));\n        vec3 tmpvar_185;\n        tmpvar_185 = (((tmpvar_183 * tmpvar_179) + (t2_173 * \n          ((tmpvar_177.yzx * tmpvar_179.zxy) - (tmpvar_177.zxy * tmpvar_179.yzx))\n        )) + (sqrt(\n          max (0.0, ((1.0 - (tmpvar_183 * tmpvar_183)) - (t2_173 * t2_173)))\n        ) * tmpvar_177));\n        vec3 tmpvar_186;\n        tmpvar_186.x = (VNDF_alpha_156 * tmpvar_185.x);\n        tmpvar_186.y = max (0.0, tmpvar_185.z);\n        tmpvar_186.z = (VNDF_alpha_156 * tmpvar_185.y);\n        vec3 tmpvar_187;\n        tmpvar_187 = normalize((basis_157 * tmpvar_186));\n        vec3 tmpvar_188;\n        tmpvar_188 = (V_152 - (2.0 * (\n          dot (tmpvar_187, V_152)\n         * tmpvar_187)));\n        float tmpvar_189;\n        tmpvar_189 = max (0.0, dot (N_153, tmpvar_188));\n        G1_NoR_170 = ((2.0 * tmpvar_189) / (tmpvar_189 + sqrt(\n          (G1_alpha_155 + ((1.0 - G1_alpha_155) * (tmpvar_189 * tmpvar_189)))\n        )));\n        vec3 tmpvar_190;\n        tmpvar_190 = normalize(tmpvar_188);\n        vec3 ray_origin_191;\n        ray_origin_191 = P_151;\n        vec3 ray_direction_192;\n        ray_direction_192 = tmpvar_190;\n        float t_hit_193;\n        t_hit_193 = 20.0;\n        vec3 position_194;\n        vec3 normal_195;\n        vec3 diffuseColor_196;\n        diffuseColor_196 = diffuse2_169;\n        vec3 specularColor_197;\n        specularColor_197 = specular2_168;\n        vec3 reflectiveColor_198;\n        reflectiveColor_198 = reflective2_167;\n        float roughness_199;\n        roughness_199 = roughness2_166;\n        bool intersectLight_200;\n        intersectLight_200 = bool(1);\n        highp int idx_203;\n        highp int intersected_204;\n        intersected_204 = 0;\n        idx_203 = 0;\n        for (highp int i_202 = 0; i_202 < numSpheres; i_202++) {\n          float t_hit_205;\n          t_hit_205 = t_hit_193;\n          bool tmpvar_206;\n          vec3 tmpvar_207;\n          tmpvar_207 = (sphereCenters[i_202] - ray_origin_191);\n          float tmpvar_208;\n          tmpvar_208 = dot (tmpvar_207, ray_direction_192);\n          if ((tmpvar_208 < 0.0)) {\n            tmpvar_206 = bool(0);\n          } else {\n            float tmpvar_209;\n            tmpvar_209 = (dot (tmpvar_207, tmpvar_207) - (tmpvar_208 * tmpvar_208));\n            if ((tmpvar_209 > 0.64)) {\n              tmpvar_206 = bool(0);\n            } else {\n              float tmpvar_210;\n              tmpvar_210 = sqrt((0.64 - tmpvar_209));\n              float tmpvar_211;\n              tmpvar_211 = (tmpvar_208 - tmpvar_210);\n              float tmpvar_212;\n              tmpvar_212 = (tmpvar_208 + tmpvar_210);\n              float tmpvar_213;\n              if ((tmpvar_211 < 0.01)) {\n                tmpvar_213 = tmpvar_212;\n              } else {\n                tmpvar_213 = tmpvar_211;\n              };\n              if (((tmpvar_213 < t_hit_193) && (tmpvar_213 > 0.01))) {\n                t_hit_205 = tmpvar_213;\n                tmpvar_206 = bool(1);\n              } else {\n                tmpvar_206 = bool(0);\n              };\n            };\n          };\n          t_hit_193 = t_hit_205;\n          if (tmpvar_206) {\n            idx_203 = i_202;\n            intersected_204 = 1;\n          };\n        };\n        for (highp int i_201 = 0; i_201 < numPlanes; i_201++) {\n          vec3 tmpvar_214;\n          tmpvar_214 = planeNormals[i_201];\n          bool tmpvar_215;\n          if (enablePlaneBacksides) {\n            tmpvar_215 = bool(1);\n          } else {\n            tmpvar_215 = (dot (ray_direction_192, tmpvar_214) < 0.0);\n          };\n          if (tmpvar_215) {\n            float t_hit_216;\n            t_hit_216 = t_hit_193;\n            bool tmpvar_217;\n            tmpvar_217 = bool(1);\n            bool tmpvar_218;\n            vec3 tmpvar_219;\n            tmpvar_219 = (tmpvar_214 * planeOffsets[i_201]);\n            float tmpvar_220;\n            tmpvar_220 = (((\n              (tmpvar_219.x + tmpvar_219.y)\n             + tmpvar_219.z) - dot (tmpvar_214, ray_origin_191)) / dot (tmpvar_214, ray_direction_192));\n            if (((tmpvar_220 < t_hit_193) && (tmpvar_220 > 0.01))) {\n              t_hit_216 = tmpvar_220;\n              tmpvar_218 = bool(1);\n              tmpvar_217 = bool(0);\n            };\n            if (tmpvar_217) {\n              tmpvar_218 = bool(0);\n              tmpvar_217 = bool(0);\n            };\n            t_hit_193 = t_hit_216;\n            if (tmpvar_218) {\n              normal_195 = tmpvar_214;\n              idx_203 = i_201;\n              intersected_204 = 2;\n            };\n          };\n        };\n        intersectLight_200 = bool(0);\n        for (highp int i_221 = 0; i_221 < numLights; i_221++) {\n          bool tmp_222;\n          vec3 tmpvar_223;\n          tmpvar_223 = lightPos[i_221];\n          vec2 tmpvar_224;\n          tmpvar_224 = lightSize[i_221];\n          tmp_222 = bool(0);\n          if (((tmpvar_224.x > 0.0) && (tmpvar_224.y > 0.0))) {\n            float t_hit_225;\n            t_hit_225 = t_hit_193;\n            bool tmpvar_226;\n            tmpvar_226 = bool(1);\n            bool tmpvar_227;\n            vec3 tmpvar_228;\n            tmpvar_228 = (vec3(0.0, 1.0, 0.0) * tmpvar_223.y);\n            float tmpvar_229;\n            tmpvar_229 = (((\n              (tmpvar_228.x + tmpvar_228.y)\n             + tmpvar_228.z) - ray_origin_191.y) / ray_direction_192.y);\n            if (((tmpvar_229 < t_hit_193) && (tmpvar_229 > 0.01))) {\n              vec3 tmpvar_230;\n              tmpvar_230 = (ray_origin_191 + (ray_direction_192 * tmpvar_229));\n              if ((((tmpvar_224.x + tmpvar_224.y) == 0.0) || ((\n                ((tmpvar_230.x < (tmpvar_223.x + (tmpvar_224.x * 0.5))) && (tmpvar_230.x > (tmpvar_223.x - (tmpvar_224.x * 0.5))))\n               && \n                (tmpvar_230.z < (tmpvar_223.z + (tmpvar_224.y * 0.5)))\n              ) && (tmpvar_230.z > \n                (tmpvar_223.z - (tmpvar_224.y * 0.5))\n              )))) {\n                t_hit_225 = tmpvar_229;\n                tmpvar_227 = bool(1);\n                tmpvar_226 = bool(0);\n              };\n            };\n            if (tmpvar_226) {\n              tmpvar_227 = bool(0);\n              tmpvar_226 = bool(0);\n            };\n            t_hit_193 = t_hit_225;\n            tmp_222 = tmpvar_227;\n          } else {\n            float t_hit_231;\n            t_hit_231 = t_hit_193;\n            bool tmpvar_232;\n            vec3 tmpvar_233;\n            tmpvar_233 = (tmpvar_223 - ray_origin_191);\n            float tmpvar_234;\n            tmpvar_234 = dot (tmpvar_233, ray_direction_192);\n            if ((tmpvar_234 < 0.0)) {\n              tmpvar_232 = bool(0);\n            } else {\n              float tmpvar_235;\n              tmpvar_235 = (dot (tmpvar_233, tmpvar_233) - (tmpvar_234 * tmpvar_234));\n              if ((tmpvar_235 > 0.01)) {\n                tmpvar_232 = bool(0);\n              } else {\n                float tmpvar_236;\n                tmpvar_236 = sqrt((0.01 - tmpvar_235));\n                float tmpvar_237;\n                tmpvar_237 = (tmpvar_234 - tmpvar_236);\n                float tmpvar_238;\n                tmpvar_238 = (tmpvar_234 + tmpvar_236);\n                float tmpvar_239;\n                if ((tmpvar_237 < 0.01)) {\n                  tmpvar_239 = tmpvar_238;\n                } else {\n                  tmpvar_239 = tmpvar_237;\n                };\n                if (((tmpvar_239 < t_hit_193) && (tmpvar_239 > 0.01))) {\n                  t_hit_231 = tmpvar_239;\n                  tmpvar_232 = bool(1);\n                } else {\n                  tmpvar_232 = bool(0);\n                };\n              };\n            };\n            t_hit_193 = t_hit_231;\n            tmp_222 = tmpvar_232;\n          };\n          if (tmp_222) {\n            idx_203 = i_221;\n            intersected_204 = 3;\n          };\n        };\n        position_194 = (P_151 + (tmpvar_190 * t_hit_193));\n        if ((intersected_204 == 1)) {\n          diffuseColor_196 = sphereColors[idx_203];\n          specularColor_197 = sphereSpecColors[idx_203];\n          reflectiveColor_198 = reflectiveColors[idx_203];\n          roughness_199 = sphereRoughness[idx_203];\n          vec3 tmpvar_240;\n          tmpvar_240 = normalize((position_194 - sphereCenters[idx_203]));\n          normal_195 = tmpvar_240;\n          float tmpvar_241;\n          tmpvar_241 = dot (tmpvar_240, -(tmpvar_190));\n          if ((tmpvar_241 < 0.0)) {\n            normal_195 = -(tmpvar_240);\n          };\n        } else {\n          if ((intersected_204 == 2)) {\n            if (!(enablePlaneMirrors)) {\n              diffuseColor_196 = planeColors[idx_203];\n              specularColor_197 = vec3(planeSpecular[idx_203]);\n              reflectiveColor_198 = vec3(0.0, 0.0, 0.0);\n              roughness_199 = planeRoughness[idx_203];\n            } else {\n              diffuseColor_196 = (planeColors[idx_203] * 0.01);\n              specularColor_197 = vec3(0.0, 0.0, 0.0);\n              reflectiveColor_198 = planeColors[idx_203];\n              roughness_199 = 1.0;\n            };\n            float tmpvar_242;\n            tmpvar_242 = dot (normal_195, -(tmpvar_190));\n            if ((tmpvar_242 < 0.0)) {\n              normal_195 = -(normal_195);\n            };\n          } else {\n            if ((intersected_204 == 3)) {\n              float spot_falloff_243;\n              spot_falloff_243 = 1.0;\n              vec2 tmpvar_244;\n              tmpvar_244 = lightSpot[idx_203];\n              if ((tmpvar_244.x > 0.0)) {\n                float tmpvar_245;\n                if ((tmpvar_190.y > tmpvar_244.x)) {\n                  tmpvar_245 = pow (tmpvar_190.y, tmpvar_244.y);\n                } else {\n                  tmpvar_245 = 0.0;\n                };\n                spot_falloff_243 = tmpvar_245;\n              };\n              diffuseColor_196 = ((spot_falloff_243 * lightBrightness[idx_203]) * 0.2);\n              intersectLight_200 = bool(1);\n            };\n          };\n        };\n        diffuse2_169 = diffuseColor_196;\n        specular2_168 = specularColor_197;\n        reflective2_167 = reflectiveColor_198;\n        roughness2_166 = roughness_199;\n        vec3 tmpvar_246;\n        if (intersectLight_200) {\n          tmpvar_246 = diffuseColor_196;\n        } else {\n          vec3 P_247;\n          P_247 = position_194;\n          vec3 N_248;\n          N_248 = normal_195;\n          vec3 diffuseColor_249;\n          diffuseColor_249 = (diffuseColor_196 + reflectiveColor_198);\n          highp int i_250;\n          vec3 illuminationColor_251;\n          i_250 = 0;\n          while (true) {\n            float spotAttenuation_252;\n            if ((i_250 >= numLights)) {\n              break;\n            };\n            vec3 tmpvar_253;\n            tmpvar_253 = (lightPos[i_250] - P_247);\n            float tmpvar_254;\n            tmpvar_254 = sqrt(dot (tmpvar_253, tmpvar_253));\n            vec3 tmpvar_255;\n            tmpvar_255 = normalize(tmpvar_253);\n            vec2 tmpvar_256;\n            tmpvar_256 = lightSpot[i_250];\n            spotAttenuation_252 = 1.0;\n            if ((tmpvar_256.x > 0.0)) {\n              float tmpvar_257;\n              if ((tmpvar_255.y > tmpvar_256.x)) {\n                tmpvar_257 = pow (tmpvar_255.y, tmpvar_256.y);\n              } else {\n                tmpvar_257 = 0.0;\n              };\n              spotAttenuation_252 = tmpvar_257;\n            };\n            if ((spotAttenuation_252 > 0.0)) {\n              vec3 lightBrightness_258;\n              lightBrightness_258 = lightBrightness[i_250];\n              float tmpvar_259;\n              tmpvar_259 = (1.0/(((attenuationFactor.x * \n                (tmpvar_254 * tmpvar_254)\n              ) + (attenuationFactor.y * tmpvar_254))));\n              if ((tmpvar_259 > 0.004)) {\n                float tmpvar_260;\n                tmpvar_260 = dot (N_248, tmpvar_255);\n                if ((tmpvar_260 > 0.0)) {\n                  vec3 ray_origin_261;\n                  ray_origin_261 = P_247;\n                  vec3 ray_direction_262;\n                  ray_direction_262 = tmpvar_255;\n                  float t_hit_263;\n                  t_hit_263 = tmpvar_254;\n                  bool tmpvar_264;\n                  bool tmpvar_265;\n                  tmpvar_265 = bool(0);\n                  highp int i_266;\n                  highp int i_267;\n                  i_267 = 0;\n                  while (true) {\n                    if ((i_267 >= numSpheres)) {\n                      break;\n                    };\n                    float t_hit_268;\n                    t_hit_268 = t_hit_263;\n                    bool tmpvar_269;\n                    vec3 tmpvar_270;\n                    tmpvar_270 = (sphereCenters[i_267] - ray_origin_261);\n                    float tmpvar_271;\n                    tmpvar_271 = dot (tmpvar_270, ray_direction_262);\n                    if ((tmpvar_271 < 0.0)) {\n                      tmpvar_269 = bool(0);\n                    } else {\n                      float tmpvar_272;\n                      tmpvar_272 = (dot (tmpvar_270, tmpvar_270) - (tmpvar_271 * tmpvar_271));\n                      if ((tmpvar_272 > 0.64)) {\n                        tmpvar_269 = bool(0);\n                      } else {\n                        float tmpvar_273;\n                        tmpvar_273 = sqrt((0.64 - tmpvar_272));\n                        float tmpvar_274;\n                        tmpvar_274 = (tmpvar_271 - tmpvar_273);\n                        float tmpvar_275;\n                        tmpvar_275 = (tmpvar_271 + tmpvar_273);\n                        float tmpvar_276;\n                        if ((tmpvar_274 < 0.001)) {\n                          tmpvar_276 = tmpvar_275;\n                        } else {\n                          tmpvar_276 = tmpvar_274;\n                        };\n                        if (((tmpvar_276 < t_hit_263) && (tmpvar_276 > 0.001))) {\n                          t_hit_268 = tmpvar_276;\n                          tmpvar_269 = bool(1);\n                        } else {\n                          tmpvar_269 = bool(0);\n                        };\n                      };\n                    };\n                    t_hit_263 = t_hit_268;\n                    if (tmpvar_269) {\n                      tmpvar_264 = bool(1);\n                      tmpvar_265 = bool(1);\n                      break;\n                    };\n                    i_267++;\n                  };\n                  if (!(tmpvar_265)) {\n                    i_266 = 0;\n                    while (true) {\n                      if ((i_266 >= numPlanes)) {\n                        break;\n                      };\n                      vec3 normal_277;\n                      normal_277 = planeNormals[i_266];\n                      float t_hit_278;\n                      t_hit_278 = t_hit_263;\n                      bool tmpvar_279;\n                      tmpvar_279 = bool(1);\n                      bool tmpvar_280;\n                      vec3 tmpvar_281;\n                      tmpvar_281 = (normal_277 * planeOffsets[i_266]);\n                      float tmpvar_282;\n                      tmpvar_282 = (((\n                        (tmpvar_281.x + tmpvar_281.y)\n                       + tmpvar_281.z) - dot (normal_277, ray_origin_261)) / dot (normal_277, ray_direction_262));\n                      if (((tmpvar_282 < t_hit_263) && (tmpvar_282 > 0.001))) {\n                        t_hit_278 = tmpvar_282;\n                        tmpvar_280 = bool(1);\n                        tmpvar_279 = bool(0);\n                      };\n                      if (tmpvar_279) {\n                        tmpvar_280 = bool(0);\n                        tmpvar_279 = bool(0);\n                      };\n                      t_hit_263 = t_hit_278;\n                      if (tmpvar_280) {\n                        tmpvar_264 = bool(1);\n                        tmpvar_265 = bool(1);\n                        break;\n                      };\n                      i_266++;\n                    };\n                    if (!(tmpvar_265)) {\n                      tmpvar_264 = bool(0);\n                      tmpvar_265 = bool(1);\n                    };\n                  };\n                  if (!(tmpvar_264)) {\n                    illuminationColor_251 = (illuminationColor_251 + ((diffuseColor_249 * lightBrightness_258) * (\n                      (tmpvar_259 * spotAttenuation_252)\n                     * tmpvar_260)));\n                  };\n                };\n              };\n            };\n            i_250++;\n          };\n          tmpvar_246 = (G1_NoR_170 * illuminationColor_251);\n        };\n        indirect_sampling_sum_158 = (indirect_sampling_sum_158 + tmpvar_246);\n      };\n      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_158 / \n        float(indirectSamples)\n      ) * diffuseColor_12));\n    } else {\n      vec3 P_283;\n      P_283 = position_10;\n      vec3 N_284;\n      N_284 = normal_11;\n      vec3 indirect_sampling_sum_286;\n      for (highp int i_285 = 0; i_285 < indirectSamples; i_285++) {\n        float roughness2_287;\n        vec3 reflective2_288;\n        vec3 specular2_289;\n        vec3 diffuse2_290;\n        float sampleIdx_291;\n        sampleIdx_291 = float(i_285);\n        randomIncrement += 0.02;\n        float tmpvar_292;\n        tmpvar_292 = ((1.0 - (\n          (sampleIdx_291 / float((indirectSamples - 1)))\n         * 2.0)) + ((\n          fract((cos(dot (\n            (P_283.xy + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n         * 0.4) - 0.2));\n        float tmpvar_293;\n        tmpvar_293 = sqrt((1.0 - (tmpvar_292 * tmpvar_292)));\n        randomIncrement += 0.02;\n        float tmpvar_294;\n        tmpvar_294 = ((2.399963 * sampleIdx_291) + ((\n          fract((cos(dot (\n            (P_283.xy + randomIncrement)\n          , vec2(23.14069, 2.665144))) * 12345.68))\n         * 0.5) - 0.25));\n        vec3 tmpvar_295;\n        tmpvar_295.x = (cos(tmpvar_294) * tmpvar_293);\n        tmpvar_295.y = tmpvar_292;\n        tmpvar_295.z = (sin(tmpvar_294) * tmpvar_293);\n        vec3 ray_origin_296;\n        ray_origin_296 = P_283;\n        vec3 ray_direction_297;\n        ray_direction_297 = normalize(normalize((N_284 + tmpvar_295)));\n        float t_hit_298;\n        t_hit_298 = 10.0;\n        vec3 position_299;\n        vec3 normal_300;\n        vec3 diffuseColor_301;\n        diffuseColor_301 = diffuse2_290;\n        vec3 specularColor_302;\n        specularColor_302 = specular2_289;\n        vec3 reflectiveColor_303;\n        reflectiveColor_303 = reflective2_288;\n        float roughness_304;\n        roughness_304 = roughness2_287;\n        highp int idx_307;\n        highp int intersected_308;\n        intersected_308 = 0;\n        idx_307 = 0;\n        for (highp int i_306 = 0; i_306 < numSpheres; i_306++) {\n          float t_hit_309;\n          t_hit_309 = t_hit_298;\n          bool tmpvar_310;\n          vec3 tmpvar_311;\n          tmpvar_311 = (sphereCenters[i_306] - ray_origin_296);\n          float tmpvar_312;\n          tmpvar_312 = dot (tmpvar_311, ray_direction_297);\n          if ((tmpvar_312 < 0.0)) {\n            tmpvar_310 = bool(0);\n          } else {\n            float tmpvar_313;\n            tmpvar_313 = (dot (tmpvar_311, tmpvar_311) - (tmpvar_312 * tmpvar_312));\n            if ((tmpvar_313 > 0.64)) {\n              tmpvar_310 = bool(0);\n            } else {\n              float tmpvar_314;\n              tmpvar_314 = sqrt((0.64 - tmpvar_313));\n              float tmpvar_315;\n              tmpvar_315 = (tmpvar_312 - tmpvar_314);\n              float tmpvar_316;\n              tmpvar_316 = (tmpvar_312 + tmpvar_314);\n              float tmpvar_317;\n              if ((tmpvar_315 < 0.01)) {\n                tmpvar_317 = tmpvar_316;\n              } else {\n                tmpvar_317 = tmpvar_315;\n              };\n              if (((tmpvar_317 < t_hit_298) && (tmpvar_317 > 0.01))) {\n                t_hit_309 = tmpvar_317;\n                tmpvar_310 = bool(1);\n              } else {\n                tmpvar_310 = bool(0);\n              };\n            };\n          };\n          t_hit_298 = t_hit_309;\n          if (tmpvar_310) {\n            idx_307 = i_306;\n            intersected_308 = 1;\n          };\n        };\n        for (highp int i_305 = 0; i_305 < numPlanes; i_305++) {\n          vec3 tmpvar_318;\n          tmpvar_318 = planeNormals[i_305];\n          bool tmpvar_319;\n          if (enablePlaneBacksides) {\n            tmpvar_319 = bool(1);\n          } else {\n            tmpvar_319 = (dot (ray_direction_297, tmpvar_318) < 0.0);\n          };\n          if (tmpvar_319) {\n            float t_hit_320;\n            t_hit_320 = t_hit_298;\n            bool tmpvar_321;\n            tmpvar_321 = bool(1);\n            bool tmpvar_322;\n            vec3 tmpvar_323;\n            tmpvar_323 = (tmpvar_318 * planeOffsets[i_305]);\n            float tmpvar_324;\n            tmpvar_324 = (((\n              (tmpvar_323.x + tmpvar_323.y)\n             + tmpvar_323.z) - dot (tmpvar_318, ray_origin_296)) / dot (tmpvar_318, ray_direction_297));\n            if (((tmpvar_324 < t_hit_298) && (tmpvar_324 > 0.01))) {\n              t_hit_320 = tmpvar_324;\n              tmpvar_322 = bool(1);\n              tmpvar_321 = bool(0);\n            };\n            if (tmpvar_321) {\n              tmpvar_322 = bool(0);\n              tmpvar_321 = bool(0);\n            };\n            t_hit_298 = t_hit_320;\n            if (tmpvar_322) {\n              normal_300 = tmpvar_318;\n              idx_307 = i_305;\n              intersected_308 = 2;\n            };\n          };\n        };\n        position_299 = (P_283 + (ray_direction_297 * t_hit_298));\n        if ((intersected_308 == 1)) {\n          diffuseColor_301 = sphereColors[idx_307];\n          specularColor_302 = sphereSpecColors[idx_307];\n          reflectiveColor_303 = reflectiveColors[idx_307];\n          roughness_304 = sphereRoughness[idx_307];\n          vec3 tmpvar_325;\n          tmpvar_325 = normalize((position_299 - sphereCenters[idx_307]));\n          normal_300 = tmpvar_325;\n          float tmpvar_326;\n          tmpvar_326 = dot (tmpvar_325, -(ray_direction_297));\n          if ((tmpvar_326 < 0.0)) {\n            normal_300 = -(tmpvar_325);\n          };\n        } else {\n          if ((intersected_308 == 2)) {\n            if (!(enablePlaneMirrors)) {\n              diffuseColor_301 = planeColors[idx_307];\n              specularColor_302 = vec3(planeSpecular[idx_307]);\n              reflectiveColor_303 = vec3(0.0, 0.0, 0.0);\n              roughness_304 = planeRoughness[idx_307];\n            } else {\n              diffuseColor_301 = (planeColors[idx_307] * 0.01);\n              specularColor_302 = vec3(0.0, 0.0, 0.0);\n              reflectiveColor_303 = planeColors[idx_307];\n              roughness_304 = 1.0;\n            };\n            float tmpvar_327;\n            tmpvar_327 = dot (normal_300, -(ray_direction_297));\n            if ((tmpvar_327 < 0.0)) {\n              normal_300 = -(normal_300);\n            };\n          } else {\n            if ((intersected_308 == 3)) {\n              float spot_falloff_328;\n              spot_falloff_328 = 1.0;\n              vec2 tmpvar_329;\n              tmpvar_329 = lightSpot[idx_307];\n              if ((tmpvar_329.x > 0.0)) {\n                float tmpvar_330;\n                if ((ray_direction_297.y > tmpvar_329.x)) {\n                  tmpvar_330 = pow (ray_direction_297.y, tmpvar_329.y);\n                } else {\n                  tmpvar_330 = 0.0;\n                };\n                spot_falloff_328 = tmpvar_330;\n              };\n              diffuseColor_301 = ((spot_falloff_328 * lightBrightness[idx_307]) * 0.2);\n            };\n          };\n        };\n        diffuse2_290 = diffuseColor_301;\n        specular2_289 = specularColor_302;\n        reflective2_288 = reflectiveColor_303;\n        roughness2_287 = roughness_304;\n        vec3 P_331;\n        P_331 = position_299;\n        vec3 N_332;\n        N_332 = normal_300;\n        vec3 diffuseColor_333;\n        diffuseColor_333 = (diffuseColor_301 + reflectiveColor_303);\n        vec3 illuminationColor_335;\n        for (highp int i_334 = 0; i_334 < numLights; i_334++) {\n          float spotAttenuation_336;\n          vec3 tmpvar_337;\n          tmpvar_337 = (lightPos[i_334] - P_331);\n          float tmpvar_338;\n          tmpvar_338 = sqrt(dot (tmpvar_337, tmpvar_337));\n          vec3 tmpvar_339;\n          tmpvar_339 = normalize(tmpvar_337);\n          vec2 tmpvar_340;\n          tmpvar_340 = lightSpot[i_334];\n          spotAttenuation_336 = 1.0;\n          if ((tmpvar_340.x > 0.0)) {\n            float tmpvar_341;\n            if ((tmpvar_339.y > tmpvar_340.x)) {\n              tmpvar_341 = pow (tmpvar_339.y, tmpvar_340.y);\n            } else {\n              tmpvar_341 = 0.0;\n            };\n            spotAttenuation_336 = tmpvar_341;\n          };\n          if ((spotAttenuation_336 > 0.0)) {\n            vec3 lightBrightness_342;\n            lightBrightness_342 = lightBrightness[i_334];\n            float tmpvar_343;\n            tmpvar_343 = (1.0/(((attenuationFactor.x * \n              (tmpvar_338 * tmpvar_338)\n            ) + (attenuationFactor.y * tmpvar_338))));\n            if ((tmpvar_343 > 0.004)) {\n              float tmpvar_344;\n              tmpvar_344 = dot (N_332, tmpvar_339);\n              if ((tmpvar_344 > 0.0)) {\n                vec3 ray_origin_345;\n                ray_origin_345 = P_331;\n                vec3 ray_direction_346;\n                ray_direction_346 = tmpvar_339;\n                float t_hit_347;\n                t_hit_347 = tmpvar_338;\n                bool tmpvar_348;\n                bool tmpvar_349;\n                tmpvar_349 = bool(0);\n                highp int i_350;\n                highp int i_351;\n                i_351 = 0;\n                while (true) {\n                  if ((i_351 >= numSpheres)) {\n                    break;\n                  };\n                  float t_hit_352;\n                  t_hit_352 = t_hit_347;\n                  bool tmpvar_353;\n                  vec3 tmpvar_354;\n                  tmpvar_354 = (sphereCenters[i_351] - ray_origin_345);\n                  float tmpvar_355;\n                  tmpvar_355 = dot (tmpvar_354, ray_direction_346);\n                  if ((tmpvar_355 < 0.0)) {\n                    tmpvar_353 = bool(0);\n                  } else {\n                    float tmpvar_356;\n                    tmpvar_356 = (dot (tmpvar_354, tmpvar_354) - (tmpvar_355 * tmpvar_355));\n                    if ((tmpvar_356 > 0.64)) {\n                      tmpvar_353 = bool(0);\n                    } else {\n                      float tmpvar_357;\n                      tmpvar_357 = sqrt((0.64 - tmpvar_356));\n                      float tmpvar_358;\n                      tmpvar_358 = (tmpvar_355 - tmpvar_357);\n                      float tmpvar_359;\n                      tmpvar_359 = (tmpvar_355 + tmpvar_357);\n                      float tmpvar_360;\n                      if ((tmpvar_358 < 0.001)) {\n                        tmpvar_360 = tmpvar_359;\n                      } else {\n                        tmpvar_360 = tmpvar_358;\n                      };\n                      if (((tmpvar_360 < t_hit_347) && (tmpvar_360 > 0.001))) {\n                        t_hit_352 = tmpvar_360;\n                        tmpvar_353 = bool(1);\n                      } else {\n                        tmpvar_353 = bool(0);\n                      };\n                    };\n                  };\n                  t_hit_347 = t_hit_352;\n                  if (tmpvar_353) {\n                    tmpvar_348 = bool(1);\n                    tmpvar_349 = bool(1);\n                    break;\n                  };\n                  i_351++;\n                };\n                if (!(tmpvar_349)) {\n                  i_350 = 0;\n                  while (true) {\n                    if ((i_350 >= numPlanes)) {\n                      break;\n                    };\n                    vec3 normal_361;\n                    normal_361 = planeNormals[i_350];\n                    float t_hit_362;\n                    t_hit_362 = t_hit_347;\n                    bool tmpvar_363;\n                    tmpvar_363 = bool(1);\n                    bool tmpvar_364;\n                    vec3 tmpvar_365;\n                    tmpvar_365 = (normal_361 * planeOffsets[i_350]);\n                    float tmpvar_366;\n                    tmpvar_366 = (((\n                      (tmpvar_365.x + tmpvar_365.y)\n                     + tmpvar_365.z) - dot (normal_361, ray_origin_345)) / dot (normal_361, ray_direction_346));\n                    if (((tmpvar_366 < t_hit_347) && (tmpvar_366 > 0.001))) {\n                      t_hit_362 = tmpvar_366;\n                      tmpvar_364 = bool(1);\n                      tmpvar_363 = bool(0);\n                    };\n                    if (tmpvar_363) {\n                      tmpvar_364 = bool(0);\n                      tmpvar_363 = bool(0);\n                    };\n                    t_hit_347 = t_hit_362;\n                    if (tmpvar_364) {\n                      tmpvar_348 = bool(1);\n                      tmpvar_349 = bool(1);\n                      break;\n                    };\n                    i_350++;\n                  };\n                  if (!(tmpvar_349)) {\n                    tmpvar_348 = bool(0);\n                    tmpvar_349 = bool(1);\n                  };\n                };\n                if (!(tmpvar_348)) {\n                  illuminationColor_335 = (illuminationColor_335 + ((diffuseColor_333 * lightBrightness_342) * (\n                    (tmpvar_343 * spotAttenuation_336)\n                   * tmpvar_344)));\n                };\n              };\n            };\n          };\n        };\n        indirect_sampling_sum_286 = (indirect_sampling_sum_286 + illuminationColor_335);\n      };\n      pixelColor_5 = (pixelColor_5 + ((indirect_sampling_sum_286 / \n        float(indirectSamples)\n      ) * diffuseColor_12));\n    };\n  };\n  bool tmpvar_367;\n  if ((rayBounces > 0)) {\n    tmpvar_367 = (sqrt(dot (reflectiveColor_14, reflectiveColor_14)) > 0.0);\n  } else {\n    tmpvar_367 = bool(0);\n  };\n  if (tmpvar_367) {\n    vec3 P_368;\n    P_368 = position_10;\n    vec3 V_369;\n    V_369 = tmpvar_6;\n    vec3 N_370;\n    N_370 = normal_11;\n    vec3 reflectiveColor_371;\n    reflectiveColor_371 = reflectiveColor_14;\n    highp int i_372;\n    vec3 reflectionSum_373;\n    i_372 = 0;\n    while (true) {\n      vec3 mirror_sample_color_374;\n      float roughness2_375;\n      vec3 reflective2_376;\n      vec3 specular2_377;\n      vec3 diffuse2_378;\n      if ((i_372 >= rayBounces)) {\n        break;\n      };\n      if ((((reflectiveColor_371.x + reflectiveColor_371.y) + reflectiveColor_371.z) == 0.0)) {\n        break;\n      };\n      vec3 tmpvar_379;\n      tmpvar_379 = (V_369 - (2.0 * (\n        dot (N_370, V_369)\n       * N_370)));\n      V_369 = tmpvar_379;\n      vec3 ray_origin_380;\n      ray_origin_380 = P_368;\n      vec3 ray_direction_381;\n      ray_direction_381 = tmpvar_379;\n      float t_hit_382;\n      t_hit_382 = 20.0;\n      vec3 position_383;\n      vec3 normal_384;\n      vec3 diffuseColor_385;\n      diffuseColor_385 = diffuse2_378;\n      vec3 specularColor_386;\n      specularColor_386 = specular2_377;\n      vec3 reflectiveColor_387;\n      reflectiveColor_387 = reflective2_376;\n      float roughness_388;\n      roughness_388 = roughness2_375;\n      bool intersectLight_389;\n      intersectLight_389 = bool(1);\n      highp int idx_392;\n      highp int intersected_393;\n      intersected_393 = 0;\n      idx_392 = 0;\n      for (highp int i_391 = 0; i_391 < numSpheres; i_391++) {\n        float t_hit_394;\n        t_hit_394 = t_hit_382;\n        bool tmpvar_395;\n        vec3 tmpvar_396;\n        tmpvar_396 = (sphereCenters[i_391] - ray_origin_380);\n        float tmpvar_397;\n        tmpvar_397 = dot (tmpvar_396, ray_direction_381);\n        if ((tmpvar_397 < 0.0)) {\n          tmpvar_395 = bool(0);\n        } else {\n          float tmpvar_398;\n          tmpvar_398 = (dot (tmpvar_396, tmpvar_396) - (tmpvar_397 * tmpvar_397));\n          if ((tmpvar_398 > 0.64)) {\n            tmpvar_395 = bool(0);\n          } else {\n            float tmpvar_399;\n            tmpvar_399 = sqrt((0.64 - tmpvar_398));\n            float tmpvar_400;\n            tmpvar_400 = (tmpvar_397 - tmpvar_399);\n            float tmpvar_401;\n            tmpvar_401 = (tmpvar_397 + tmpvar_399);\n            float tmpvar_402;\n            if ((tmpvar_400 < 0.01)) {\n              tmpvar_402 = tmpvar_401;\n            } else {\n              tmpvar_402 = tmpvar_400;\n            };\n            if (((tmpvar_402 < t_hit_382) && (tmpvar_402 > 0.01))) {\n              t_hit_394 = tmpvar_402;\n              tmpvar_395 = bool(1);\n            } else {\n              tmpvar_395 = bool(0);\n            };\n          };\n        };\n        t_hit_382 = t_hit_394;\n        if (tmpvar_395) {\n          idx_392 = i_391;\n          intersected_393 = 1;\n        };\n      };\n      for (highp int i_390 = 0; i_390 < numPlanes; i_390++) {\n        vec3 tmpvar_403;\n        tmpvar_403 = planeNormals[i_390];\n        bool tmpvar_404;\n        if (enablePlaneBacksides) {\n          tmpvar_404 = bool(1);\n        } else {\n          tmpvar_404 = (dot (ray_direction_381, tmpvar_403) < 0.0);\n        };\n        if (tmpvar_404) {\n          float t_hit_405;\n          t_hit_405 = t_hit_382;\n          bool tmpvar_406;\n          tmpvar_406 = bool(1);\n          bool tmpvar_407;\n          vec3 tmpvar_408;\n          tmpvar_408 = (tmpvar_403 * planeOffsets[i_390]);\n          float tmpvar_409;\n          tmpvar_409 = (((\n            (tmpvar_408.x + tmpvar_408.y)\n           + tmpvar_408.z) - dot (tmpvar_403, ray_origin_380)) / dot (tmpvar_403, ray_direction_381));\n          if (((tmpvar_409 < t_hit_382) && (tmpvar_409 > 0.01))) {\n            t_hit_405 = tmpvar_409;\n            tmpvar_407 = bool(1);\n            tmpvar_406 = bool(0);\n          };\n          if (tmpvar_406) {\n            tmpvar_407 = bool(0);\n            tmpvar_406 = bool(0);\n          };\n          t_hit_382 = t_hit_405;\n          if (tmpvar_407) {\n            normal_384 = tmpvar_403;\n            idx_392 = i_390;\n            intersected_393 = 2;\n          };\n        };\n      };\n      intersectLight_389 = bool(0);\n      for (highp int i_410 = 0; i_410 < numLights; i_410++) {\n        bool tmp_411;\n        vec3 tmpvar_412;\n        tmpvar_412 = lightPos[i_410];\n        vec2 tmpvar_413;\n        tmpvar_413 = lightSize[i_410];\n        tmp_411 = bool(0);\n        if (((tmpvar_413.x > 0.0) && (tmpvar_413.y > 0.0))) {\n          float t_hit_414;\n          t_hit_414 = t_hit_382;\n          bool tmpvar_415;\n          tmpvar_415 = bool(1);\n          bool tmpvar_416;\n          vec3 tmpvar_417;\n          tmpvar_417 = (vec3(0.0, 1.0, 0.0) * tmpvar_412.y);\n          float tmpvar_418;\n          tmpvar_418 = (((\n            (tmpvar_417.x + tmpvar_417.y)\n           + tmpvar_417.z) - ray_origin_380.y) / ray_direction_381.y);\n          if (((tmpvar_418 < t_hit_382) && (tmpvar_418 > 0.01))) {\n            vec3 tmpvar_419;\n            tmpvar_419 = (ray_origin_380 + (ray_direction_381 * tmpvar_418));\n            if ((((tmpvar_413.x + tmpvar_413.y) == 0.0) || ((\n              ((tmpvar_419.x < (tmpvar_412.x + (tmpvar_413.x * 0.5))) && (tmpvar_419.x > (tmpvar_412.x - (tmpvar_413.x * 0.5))))\n             && \n              (tmpvar_419.z < (tmpvar_412.z + (tmpvar_413.y * 0.5)))\n            ) && (tmpvar_419.z > \n              (tmpvar_412.z - (tmpvar_413.y * 0.5))\n            )))) {\n              t_hit_414 = tmpvar_418;\n              tmpvar_416 = bool(1);\n              tmpvar_415 = bool(0);\n            };\n          };\n          if (tmpvar_415) {\n            tmpvar_416 = bool(0);\n            tmpvar_415 = bool(0);\n          };\n          t_hit_382 = t_hit_414;\n          tmp_411 = tmpvar_416;\n        } else {\n          float t_hit_420;\n          t_hit_420 = t_hit_382;\n          bool tmpvar_421;\n          vec3 tmpvar_422;\n          tmpvar_422 = (tmpvar_412 - ray_origin_380);\n          float tmpvar_423;\n          tmpvar_423 = dot (tmpvar_422, ray_direction_381);\n          if ((tmpvar_423 < 0.0)) {\n            tmpvar_421 = bool(0);\n          } else {\n            float tmpvar_424;\n            tmpvar_424 = (dot (tmpvar_422, tmpvar_422) - (tmpvar_423 * tmpvar_423));\n            if ((tmpvar_424 > 0.01)) {\n              tmpvar_421 = bool(0);\n            } else {\n              float tmpvar_425;\n              tmpvar_425 = sqrt((0.01 - tmpvar_424));\n              float tmpvar_426;\n              tmpvar_426 = (tmpvar_423 - tmpvar_425);\n              float tmpvar_427;\n              tmpvar_427 = (tmpvar_423 + tmpvar_425);\n              float tmpvar_428;\n              if ((tmpvar_426 < 0.01)) {\n                tmpvar_428 = tmpvar_427;\n              } else {\n                tmpvar_428 = tmpvar_426;\n              };\n              if (((tmpvar_428 < t_hit_382) && (tmpvar_428 > 0.01))) {\n                t_hit_420 = tmpvar_428;\n                tmpvar_421 = bool(1);\n              } else {\n                tmpvar_421 = bool(0);\n              };\n            };\n          };\n          t_hit_382 = t_hit_420;\n          tmp_411 = tmpvar_421;\n        };\n        if (tmp_411) {\n          idx_392 = i_410;\n          intersected_393 = 3;\n        };\n      };\n      position_383 = (P_368 + (tmpvar_379 * t_hit_382));\n      if ((intersected_393 == 1)) {\n        diffuseColor_385 = sphereColors[idx_392];\n        specularColor_386 = sphereSpecColors[idx_392];\n        reflectiveColor_387 = reflectiveColors[idx_392];\n        roughness_388 = sphereRoughness[idx_392];\n        vec3 tmpvar_429;\n        tmpvar_429 = normalize((position_383 - sphereCenters[idx_392]));\n        normal_384 = tmpvar_429;\n        float tmpvar_430;\n        tmpvar_430 = dot (tmpvar_429, -(tmpvar_379));\n        if ((tmpvar_430 < 0.0)) {\n          normal_384 = -(tmpvar_429);\n        };\n      } else {\n        if ((intersected_393 == 2)) {\n          if (!(enablePlaneMirrors)) {\n            diffuseColor_385 = planeColors[idx_392];\n            specularColor_386 = vec3(planeSpecular[idx_392]);\n            reflectiveColor_387 = vec3(0.0, 0.0, 0.0);\n            roughness_388 = planeRoughness[idx_392];\n          } else {\n            diffuseColor_385 = (planeColors[idx_392] * 0.01);\n            specularColor_386 = vec3(0.0, 0.0, 0.0);\n            reflectiveColor_387 = planeColors[idx_392];\n            roughness_388 = 1.0;\n          };\n          float tmpvar_431;\n          tmpvar_431 = dot (normal_384, -(tmpvar_379));\n          if ((tmpvar_431 < 0.0)) {\n            normal_384 = -(normal_384);\n          };\n        } else {\n          if ((intersected_393 == 3)) {\n            float spot_falloff_432;\n            spot_falloff_432 = 1.0;\n            vec2 tmpvar_433;\n            tmpvar_433 = lightSpot[idx_392];\n            if ((tmpvar_433.x > 0.0)) {\n              float tmpvar_434;\n              if ((tmpvar_379.y > tmpvar_433.x)) {\n                tmpvar_434 = pow (tmpvar_379.y, tmpvar_433.y);\n              } else {\n                tmpvar_434 = 0.0;\n              };\n              spot_falloff_432 = tmpvar_434;\n            };\n            diffuseColor_385 = ((spot_falloff_432 * lightBrightness[idx_392]) * 0.2);\n            intersectLight_389 = bool(1);\n          };\n        };\n      };\n      N_370 = normal_384;\n      diffuse2_378 = diffuseColor_385;\n      specular2_377 = specularColor_386;\n      reflective2_376 = reflectiveColor_387;\n      roughness2_375 = roughness_388;\n      vec3 tmpvar_435;\n      if (intersectLight_389) {\n        tmpvar_435 = diffuseColor_385;\n      } else {\n        vec3 P_436;\n        P_436 = position_383;\n        vec3 V_437;\n        V_437 = tmpvar_379;\n        vec3 N_438;\n        N_438 = normal_384;\n        vec3 diffuseColor_439;\n        diffuseColor_439 = diffuseColor_385;\n        vec3 specularColor_440;\n        specularColor_440 = specularColor_386;\n        highp int i_441;\n        vec3 illuminationColor_442;\n        i_441 = 0;\n        while (true) {\n          highp int k_443;\n          bool inShade_444;\n          highp int areaShadowSamples_445;\n          vec3 light_sum_446;\n          vec2 lightSpot_447;\n          vec2 lightSize_448;\n          vec3 lightBrightness_449;\n          vec3 lightPos_450;\n          if ((i_441 >= numLights)) {\n            break;\n          };\n          lightPos_450 = lightPos[i_441];\n          lightBrightness_449 = lightBrightness[i_441];\n          lightSize_448 = lightSize[i_441];\n          lightSpot_447 = lightSpot[i_441];\n          areaShadowSamples_445 = 0;\n          inShade_444 = bool(0);\n          k_443 = 0;\n          while (true) {\n            vec3 testPos_451;\n            if ((k_443 >= 1)) {\n              break;\n            };\n            if (inShade_444) {\n              break;\n            };\n            testPos_451 = lightPos_450;\n            if ((k_443 == 1)) {\n              testPos_451.x = (lightPos_450.x - (lightSize_448.x * 0.5));\n              testPos_451.z = (lightPos_450.z - (lightSize_448.y * 0.5));\n            } else {\n              if ((k_443 == 2)) {\n                testPos_451.x = (testPos_451.x + (lightSize_448.x * 0.5));\n                testPos_451.z = (testPos_451.z + (lightSize_448.y * 0.5));\n              } else {\n                if ((k_443 == 3)) {\n                  testPos_451.x = (testPos_451.x + (lightSize_448.x * 0.5));\n                  testPos_451.z = (testPos_451.z - (lightSize_448.y * 0.5));\n                } else {\n                  if ((k_443 == 4)) {\n                    testPos_451.x = (testPos_451.x - (lightSize_448.x * 0.5));\n                    testPos_451.z = (testPos_451.z + (lightSize_448.y * 0.5));\n                  };\n                };\n              };\n            };\n            vec3 L_452;\n            vec3 incidentIntensity_453;\n            float falloff_454;\n            L_452 = (testPos_451 - P_436);\n            float tmpvar_455;\n            tmpvar_455 = sqrt(dot (L_452, L_452));\n            float tmpvar_456;\n            tmpvar_456 = (1.0/(((attenuationFactor.x * \n              (tmpvar_455 * tmpvar_455)\n            ) + (attenuationFactor.y * tmpvar_455))));\n            vec3 tmpvar_457;\n            tmpvar_457 = normalize(L_452);\n            L_452 = tmpvar_457;\n            falloff_454 = 1.0;\n            if ((lightSpot_447.x > 0.0)) {\n              float tmpvar_458;\n              if ((tmpvar_457.y > lightSpot_447.x)) {\n                tmpvar_458 = pow (tmpvar_457.y, lightSpot_447.y);\n              } else {\n                tmpvar_458 = 0.0;\n              };\n              falloff_454 = tmpvar_458;\n            };\n            incidentIntensity_453 = ((lightBrightness_449 * tmpvar_456) * falloff_454);\n            float tmpvar_459;\n            tmpvar_459 = dot (N_438, tmpvar_457);\n            if (((tmpvar_459 > 0.0) && ((\n              (incidentIntensity_453.x + incidentIntensity_453.y)\n             + incidentIntensity_453.z) > 0.01))) {\n              vec3 ray_origin_460;\n              ray_origin_460 = P_436;\n              vec3 ray_direction_461;\n              ray_direction_461 = tmpvar_457;\n              float t_hit_462;\n              t_hit_462 = tmpvar_455;\n              bool tmpvar_463;\n              tmpvar_463 = bool(0);\n              highp int i_464;\n              highp int i_465;\n              i_465 = 0;\n              while (true) {\n                if ((i_465 >= numSpheres)) {\n                  break;\n                };\n                float t_hit_466;\n                t_hit_466 = t_hit_462;\n                bool tmpvar_467;\n                vec3 tmpvar_468;\n                tmpvar_468 = (sphereCenters[i_465] - ray_origin_460);\n                float tmpvar_469;\n                tmpvar_469 = dot (tmpvar_468, ray_direction_461);\n                if ((tmpvar_469 < 0.0)) {\n                  tmpvar_467 = bool(0);\n                } else {\n                  float tmpvar_470;\n                  tmpvar_470 = (dot (tmpvar_468, tmpvar_468) - (tmpvar_469 * tmpvar_469));\n                  if ((tmpvar_470 > 0.64)) {\n                    tmpvar_467 = bool(0);\n                  } else {\n                    float tmpvar_471;\n                    tmpvar_471 = sqrt((0.64 - tmpvar_470));\n                    float tmpvar_472;\n                    tmpvar_472 = (tmpvar_469 - tmpvar_471);\n                    float tmpvar_473;\n                    tmpvar_473 = (tmpvar_469 + tmpvar_471);\n                    float tmpvar_474;\n                    if ((tmpvar_472 < 0.001)) {\n                      tmpvar_474 = tmpvar_473;\n                    } else {\n                      tmpvar_474 = tmpvar_472;\n                    };\n                    if (((tmpvar_474 < t_hit_462) && (tmpvar_474 > 0.001))) {\n                      t_hit_466 = tmpvar_474;\n                      tmpvar_467 = bool(1);\n                    } else {\n                      tmpvar_467 = bool(0);\n                    };\n                  };\n                };\n                t_hit_462 = t_hit_466;\n                if (tmpvar_467) {\n                  tmpvar_463 = bool(1);\n                  break;\n                };\n                i_465++;\n              };\n              if (!(tmpvar_463)) {\n                i_464 = 0;\n                while (true) {\n                  if ((i_464 >= numPlanes)) {\n                    break;\n                  };\n                  vec3 normal_475;\n                  normal_475 = planeNormals[i_464];\n                  float t_hit_476;\n                  t_hit_476 = t_hit_462;\n                  bool tmpvar_477;\n                  tmpvar_477 = bool(1);\n                  bool tmpvar_478;\n                  vec3 tmpvar_479;\n                  tmpvar_479 = (normal_475 * planeOffsets[i_464]);\n                  float tmpvar_480;\n                  tmpvar_480 = (((\n                    (tmpvar_479.x + tmpvar_479.y)\n                   + tmpvar_479.z) - dot (normal_475, ray_origin_460)) / dot (normal_475, ray_direction_461));\n                  if (((tmpvar_480 < t_hit_462) && (tmpvar_480 > 0.001))) {\n                    t_hit_476 = tmpvar_480;\n                    tmpvar_478 = bool(1);\n                    tmpvar_477 = bool(0);\n                  };\n                  if (tmpvar_477) {\n                    tmpvar_478 = bool(0);\n                    tmpvar_477 = bool(0);\n                  };\n                  t_hit_462 = t_hit_476;\n                  if (tmpvar_478) {\n                    tmpvar_463 = bool(1);\n                    break;\n                  };\n                  i_464++;\n                };\n                if (!(tmpvar_463)) {\n                  tmpvar_463 = bool(1);\n                };\n              };\n              float tmpvar_481;\n              tmpvar_481 = abs((t_hit_462 - tmpvar_455));\n              if ((tmpvar_481 < 0.001)) {\n                vec3 I_482;\n                I_482 = -(tmpvar_457);\n                light_sum_446 = (light_sum_446 + (incidentIntensity_453 * (\n                  (diffuseColor_439 * dot (N_438, tmpvar_457))\n                 + \n                  (specularColor_440 * pow (max (0.0, dot (\n                    (I_482 - (2.0 * (dot (N_438, I_482) * N_438)))\n                  , \n                    -(V_437)\n                  )), 128.0))\n                )));\n              } else {\n                inShade_444 = bool(1);\n              };\n            } else {\n              inShade_444 = bool(1);\n            };\n            areaShadowSamples_445++;\n            k_443++;\n          };\n          illuminationColor_442 = (illuminationColor_442 + (light_sum_446 / float(areaShadowSamples_445)));\n          i_441++;\n        };\n        tmpvar_435 = illuminationColor_442;\n      };\n      mirror_sample_color_374 = tmpvar_435;\n      if (enableRefGI) {\n        vec3 P_483;\n        P_483 = position_383;\n        vec3 N_484;\n        N_484 = normal_384;\n        highp int i_485;\n        vec3 indirect_sampling_sum_486;\n        i_485 = 0;\n        while (true) {\n          float roughness2_487;\n          vec3 reflective2_488;\n          vec3 specular2_489;\n          vec3 diffuse2_490;\n          if ((i_485 >= indirectSamples)) {\n            break;\n          };\n          float sampleIdx_491;\n          sampleIdx_491 = float(i_485);\n          randomIncrement += 0.02;\n          float tmpvar_492;\n          tmpvar_492 = ((1.0 - (\n            (sampleIdx_491 / float((indirectSamples - 1)))\n           * 2.0)) + ((\n            fract((cos(dot (\n              (P_483.xy + randomIncrement)\n            , vec2(23.14069, 2.665144))) * 12345.68))\n           * 0.4) - 0.2));\n          float tmpvar_493;\n          tmpvar_493 = sqrt((1.0 - (tmpvar_492 * tmpvar_492)));\n          randomIncrement += 0.02;\n          float tmpvar_494;\n          tmpvar_494 = ((2.399963 * sampleIdx_491) + ((\n            fract((cos(dot (\n              (P_483.xy + randomIncrement)\n            , vec2(23.14069, 2.665144))) * 12345.68))\n           * 0.5) - 0.25));\n          vec3 tmpvar_495;\n          tmpvar_495.x = (cos(tmpvar_494) * tmpvar_493);\n          tmpvar_495.y = tmpvar_492;\n          tmpvar_495.z = (sin(tmpvar_494) * tmpvar_493);\n          vec3 ray_origin_496;\n          ray_origin_496 = P_483;\n          vec3 ray_direction_497;\n          ray_direction_497 = normalize(normalize((N_484 + tmpvar_495)));\n          float t_hit_498;\n          t_hit_498 = 10.0;\n          vec3 position_499;\n          vec3 normal_500;\n          vec3 diffuseColor_501;\n          diffuseColor_501 = diffuse2_490;\n          vec3 specularColor_502;\n          specularColor_502 = specular2_489;\n          vec3 reflectiveColor_503;\n          reflectiveColor_503 = reflective2_488;\n          float roughness_504;\n          roughness_504 = roughness2_487;\n          highp int i_505;\n          highp int i_506;\n          highp int idx_507;\n          highp int intersected_508;\n          intersected_508 = 0;\n          idx_507 = 0;\n          i_506 = 0;\n          while (true) {\n            if ((i_506 >= numSpheres)) {\n              break;\n            };\n            float t_hit_509;\n            t_hit_509 = t_hit_498;\n            bool tmpvar_510;\n            vec3 tmpvar_511;\n            tmpvar_511 = (sphereCenters[i_506] - ray_origin_496);\n            float tmpvar_512;\n            tmpvar_512 = dot (tmpvar_511, ray_direction_497);\n            if ((tmpvar_512 < 0.0)) {\n              tmpvar_510 = bool(0);\n            } else {\n              float tmpvar_513;\n              tmpvar_513 = (dot (tmpvar_511, tmpvar_511) - (tmpvar_512 * tmpvar_512));\n              if ((tmpvar_513 > 0.64)) {\n                tmpvar_510 = bool(0);\n              } else {\n                float tmpvar_514;\n                tmpvar_514 = sqrt((0.64 - tmpvar_513));\n                float tmpvar_515;\n                tmpvar_515 = (tmpvar_512 - tmpvar_514);\n                float tmpvar_516;\n                tmpvar_516 = (tmpvar_512 + tmpvar_514);\n                float tmpvar_517;\n                if ((tmpvar_515 < 0.01)) {\n                  tmpvar_517 = tmpvar_516;\n                } else {\n                  tmpvar_517 = tmpvar_515;\n                };\n                if (((tmpvar_517 < t_hit_498) && (tmpvar_517 > 0.01))) {\n                  t_hit_509 = tmpvar_517;\n                  tmpvar_510 = bool(1);\n                } else {\n                  tmpvar_510 = bool(0);\n                };\n              };\n            };\n            t_hit_498 = t_hit_509;\n            if (tmpvar_510) {\n              idx_507 = i_506;\n              intersected_508 = 1;\n            };\n            i_506++;\n          };\n          i_505 = 0;\n          while (true) {\n            if ((i_505 >= numPlanes)) {\n              break;\n            };\n            vec3 tmpvar_518;\n            tmpvar_518 = planeNormals[i_505];\n            bool tmpvar_519;\n            if (enablePlaneBacksides) {\n              tmpvar_519 = bool(1);\n            } else {\n              tmpvar_519 = (dot (ray_direction_497, tmpvar_518) < 0.0);\n            };\n            if (tmpvar_519) {\n              float t_hit_520;\n              t_hit_520 = t_hit_498;\n              bool tmpvar_521;\n              tmpvar_521 = bool(1);\n              bool tmpvar_522;\n              vec3 tmpvar_523;\n              tmpvar_523 = (tmpvar_518 * planeOffsets[i_505]);\n              float tmpvar_524;\n              tmpvar_524 = (((\n                (tmpvar_523.x + tmpvar_523.y)\n               + tmpvar_523.z) - dot (tmpvar_518, ray_origin_496)) / dot (tmpvar_518, ray_direction_497));\n              if (((tmpvar_524 < t_hit_498) && (tmpvar_524 > 0.01))) {\n                t_hit_520 = tmpvar_524;\n                tmpvar_522 = bool(1);\n                tmpvar_521 = bool(0);\n              };\n              if (tmpvar_521) {\n                tmpvar_522 = bool(0);\n                tmpvar_521 = bool(0);\n              };\n              t_hit_498 = t_hit_520;\n              if (tmpvar_522) {\n                normal_500 = tmpvar_518;\n                idx_507 = i_505;\n                intersected_508 = 2;\n              };\n            };\n            i_505++;\n          };\n          position_499 = (P_483 + (ray_direction_497 * t_hit_498));\n          if ((intersected_508 == 1)) {\n            diffuseColor_501 = sphereColors[idx_507];\n            specularColor_502 = sphereSpecColors[idx_507];\n            reflectiveColor_503 = reflectiveColors[idx_507];\n            roughness_504 = sphereRoughness[idx_507];\n            vec3 tmpvar_525;\n            tmpvar_525 = normalize((position_499 - sphereCenters[idx_507]));\n            normal_500 = tmpvar_525;\n            float tmpvar_526;\n            tmpvar_526 = dot (tmpvar_525, -(ray_direction_497));\n            if ((tmpvar_526 < 0.0)) {\n              normal_500 = -(tmpvar_525);\n            };\n          } else {\n            if ((intersected_508 == 2)) {\n              if (!(enablePlaneMirrors)) {\n                diffuseColor_501 = planeColors[idx_507];\n                specularColor_502 = vec3(planeSpecular[idx_507]);\n                reflectiveColor_503 = vec3(0.0, 0.0, 0.0);\n                roughness_504 = planeRoughness[idx_507];\n              } else {\n                diffuseColor_501 = (planeColors[idx_507] * 0.01);\n                specularColor_502 = vec3(0.0, 0.0, 0.0);\n                reflectiveColor_503 = planeColors[idx_507];\n                roughness_504 = 1.0;\n              };\n              float tmpvar_527;\n              tmpvar_527 = dot (normal_500, -(ray_direction_497));\n              if ((tmpvar_527 < 0.0)) {\n                normal_500 = -(normal_500);\n              };\n            } else {\n              if ((intersected_508 == 3)) {\n                float spot_falloff_528;\n                spot_falloff_528 = 1.0;\n                vec2 tmpvar_529;\n                tmpvar_529 = lightSpot[idx_507];\n                if ((tmpvar_529.x > 0.0)) {\n                  float tmpvar_530;\n                  if ((ray_direction_497.y > tmpvar_529.x)) {\n                    tmpvar_530 = pow (ray_direction_497.y, tmpvar_529.y);\n                  } else {\n                    tmpvar_530 = 0.0;\n                  };\n                  spot_falloff_528 = tmpvar_530;\n                };\n                diffuseColor_501 = ((spot_falloff_528 * lightBrightness[idx_507]) * 0.2);\n              };\n            };\n          };\n          diffuse2_490 = diffuseColor_501;\n          specular2_489 = specularColor_502;\n          reflective2_488 = reflectiveColor_503;\n          roughness2_487 = roughness_504;\n          vec3 P_531;\n          P_531 = position_499;\n          vec3 N_532;\n          N_532 = normal_500;\n          vec3 diffuseColor_533;\n          diffuseColor_533 = (diffuseColor_501 + reflectiveColor_503);\n          highp int i_534;\n          vec3 illuminationColor_535;\n          i_534 = 0;\n          while (true) {\n            float spotAttenuation_536;\n            if ((i_534 >= numLights)) {\n              break;\n            };\n            vec3 tmpvar_537;\n            tmpvar_537 = (lightPos[i_534] - P_531);\n            float tmpvar_538;\n            tmpvar_538 = sqrt(dot (tmpvar_537, tmpvar_537));\n            vec3 tmpvar_539;\n            tmpvar_539 = normalize(tmpvar_537);\n            vec2 tmpvar_540;\n            tmpvar_540 = lightSpot[i_534];\n            spotAttenuation_536 = 1.0;\n            if ((tmpvar_540.x > 0.0)) {\n              float tmpvar_541;\n              if ((tmpvar_539.y > tmpvar_540.x)) {\n                tmpvar_541 = pow (tmpvar_539.y, tmpvar_540.y);\n              } else {\n                tmpvar_541 = 0.0;\n              };\n              spotAttenuation_536 = tmpvar_541;\n            };\n            if ((spotAttenuation_536 > 0.0)) {\n              vec3 lightBrightness_542;\n              lightBrightness_542 = lightBrightness[i_534];\n              float tmpvar_543;\n              tmpvar_543 = (1.0/(((attenuationFactor.x * \n                (tmpvar_538 * tmpvar_538)\n              ) + (attenuationFactor.y * tmpvar_538))));\n              if ((tmpvar_543 > 0.004)) {\n                float tmpvar_544;\n                tmpvar_544 = dot (N_532, tmpvar_539);\n                if ((tmpvar_544 > 0.0)) {\n                  vec3 ray_origin_545;\n                  ray_origin_545 = P_531;\n                  vec3 ray_direction_546;\n                  ray_direction_546 = tmpvar_539;\n                  float t_hit_547;\n                  t_hit_547 = tmpvar_538;\n                  bool tmpvar_548;\n                  bool tmpvar_549;\n                  tmpvar_549 = bool(0);\n                  highp int i_550;\n                  highp int i_551;\n                  i_551 = 0;\n                  while (true) {\n                    if ((i_551 >= numSpheres)) {\n                      break;\n                    };\n                    float t_hit_552;\n                    t_hit_552 = t_hit_547;\n                    bool tmpvar_553;\n                    vec3 tmpvar_554;\n                    tmpvar_554 = (sphereCenters[i_551] - ray_origin_545);\n                    float tmpvar_555;\n                    tmpvar_555 = dot (tmpvar_554, ray_direction_546);\n                    if ((tmpvar_555 < 0.0)) {\n                      tmpvar_553 = bool(0);\n                    } else {\n                      float tmpvar_556;\n                      tmpvar_556 = (dot (tmpvar_554, tmpvar_554) - (tmpvar_555 * tmpvar_555));\n                      if ((tmpvar_556 > 0.64)) {\n                        tmpvar_553 = bool(0);\n                      } else {\n                        float tmpvar_557;\n                        tmpvar_557 = sqrt((0.64 - tmpvar_556));\n                        float tmpvar_558;\n                        tmpvar_558 = (tmpvar_555 - tmpvar_557);\n                        float tmpvar_559;\n                        tmpvar_559 = (tmpvar_555 + tmpvar_557);\n                        float tmpvar_560;\n                        if ((tmpvar_558 < 0.001)) {\n                          tmpvar_560 = tmpvar_559;\n                        } else {\n                          tmpvar_560 = tmpvar_558;\n                        };\n                        if (((tmpvar_560 < t_hit_547) && (tmpvar_560 > 0.001))) {\n                          t_hit_552 = tmpvar_560;\n                          tmpvar_553 = bool(1);\n                        } else {\n                          tmpvar_553 = bool(0);\n                        };\n                      };\n                    };\n                    t_hit_547 = t_hit_552;\n                    if (tmpvar_553) {\n                      tmpvar_548 = bool(1);\n                      tmpvar_549 = bool(1);\n                      break;\n                    };\n                    i_551++;\n                  };\n                  if (!(tmpvar_549)) {\n                    i_550 = 0;\n                    while (true) {\n                      if ((i_550 >= numPlanes)) {\n                        break;\n                      };\n                      vec3 normal_561;\n                      normal_561 = planeNormals[i_550];\n                      float t_hit_562;\n                      t_hit_562 = t_hit_547;\n                      bool tmpvar_563;\n                      tmpvar_563 = bool(1);\n                      bool tmpvar_564;\n                      vec3 tmpvar_565;\n                      tmpvar_565 = (normal_561 * planeOffsets[i_550]);\n                      float tmpvar_566;\n                      tmpvar_566 = (((\n                        (tmpvar_565.x + tmpvar_565.y)\n                       + tmpvar_565.z) - dot (normal_561, ray_origin_545)) / dot (normal_561, ray_direction_546));\n                      if (((tmpvar_566 < t_hit_547) && (tmpvar_566 > 0.001))) {\n                        t_hit_562 = tmpvar_566;\n                        tmpvar_564 = bool(1);\n                        tmpvar_563 = bool(0);\n                      };\n                      if (tmpvar_563) {\n                        tmpvar_564 = bool(0);\n                        tmpvar_563 = bool(0);\n                      };\n                      t_hit_547 = t_hit_562;\n                      if (tmpvar_564) {\n                        tmpvar_548 = bool(1);\n                        tmpvar_549 = bool(1);\n                        break;\n                      };\n                      i_550++;\n                    };\n                    if (!(tmpvar_549)) {\n                      tmpvar_548 = bool(0);\n                      tmpvar_549 = bool(1);\n                    };\n                  };\n                  if (!(tmpvar_548)) {\n                    illuminationColor_535 = (illuminationColor_535 + ((diffuseColor_533 * lightBrightness_542) * (\n                      (tmpvar_543 * spotAttenuation_536)\n                     * tmpvar_544)));\n                  };\n                };\n              };\n            };\n            i_534++;\n          };\n          indirect_sampling_sum_486 = (indirect_sampling_sum_486 + illuminationColor_535);\n          i_485++;\n        };\n        mirror_sample_color_374 = (tmpvar_435 + ((indirect_sampling_sum_486 / \n          float(indirectSamples)\n        ) * diffuseColor_385));\n      } else {\n        mirror_sample_color_374 = (mirror_sample_color_374 + (ambientLight * diffuseColor_385));\n      };\n      P_368 = position_383;\n      reflectionSum_373 = (reflectionSum_373 + (mirror_sample_color_374 * reflectiveColor_371));\n      reflectiveColor_371 = (reflectiveColor_387 * reflectiveColor_371);\n      i_372++;\n    };\n    pixelColor_5 = (pixelColor_5 + reflectionSum_373);\n  };\n  lowp vec3 x_567;\n  x_567 = (mat3(0.59719, 0.076, 0.0284, 0.35458, 0.90834, 0.13383, 0.04823, 0.01566, 0.83777) * pixelColor_5);\n  x_567 = (((x_567 * \n    (x_567 + 0.0245786)\n  ) - 9.0537e-05) / ((x_567 * \n    ((0.983729 * x_567) + 0.432951)\n  ) + 0.238081));\n  x_567 = (mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276, -0.07367, -0.00605, 1.07602) * x_567);\n  lowp vec3 tmpvar_568;\n  tmpvar_568 = clamp (x_567, 0.0, 1.0);\n  pixelColor_5 = tmpvar_568;\n  lowp vec3 tmpvar_569;\n  tmpvar_569 = pow (tmpvar_568, vec3(0.4545454, 0.4545454, 0.4545454));\n  float tmpvar_570;\n  if ((tmpvar_568.x < 0.0031308)) {\n    tmpvar_570 = 1.0;\n  } else {\n    tmpvar_570 = 0.0;\n  };\n  float tmpvar_571;\n  if ((tmpvar_568.y < 0.0031308)) {\n    tmpvar_571 = 1.0;\n  } else {\n    tmpvar_571 = 0.0;\n  };\n  float tmpvar_572;\n  if ((tmpvar_568.z < 0.0031308)) {\n    tmpvar_572 = 1.0;\n  } else {\n    tmpvar_572 = 0.0;\n  };\n  vec3 tmpvar_573;\n  tmpvar_573.x = tmpvar_570;\n  tmpvar_573.y = tmpvar_571;\n  tmpvar_573.z = tmpvar_572;\n  lowp vec3 tmpvar_574;\n  tmpvar_574 = mix (((tmpvar_569 * 1.055) - 0.055), (tmpvar_568 * 12.92), tmpvar_573);\n  pixelColor_5 = tmpvar_574;\n  lowp vec4 tmpvar_575;\n  if (enableTAA) {\n    lowp vec4 tmpvar_576;\n    tmpvar_576.w = 1.0;\n    tmpvar_576.xyz = tmpvar_574;\n    tmpvar_575 = ((0.1 * min (tmpvar_576, 1.0)) + (0.9 * texture (u_texture, texCoord)));\n  } else {\n    lowp vec4 tmpvar_577;\n    tmpvar_577.w = 1.0;\n    tmpvar_577.xyz = tmpvar_574;\n    tmpvar_575 = tmpvar_577;\n  };\n  fragColor = tmpvar_575;\n}"},675:n=>{n.exports="#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform mat4 invprojview;\nuniform float near;\nuniform float far;\n\nout vec3 origin;\nout vec3 ray;\nout vec2 texCoord;\n\nvoid main() {\n    // https://rauwendaal.net/2014/06/14/rendering-a-screen-covering-triangle-in-opengl/\n    float x = -1.0 + float((gl_VertexID & 1) << 2);\n    float y = -1.0 + float((gl_VertexID & 2) << 1);\n    texCoord.x = (x+1.0)*0.5;\n    texCoord.y = (y+1.0)*0.5;\n    gl_Position = vec4(x, y, 0, 1);\n                \n    // https://stackoverflow.com/a/52764898\n    origin = (invprojview * vec4(x, y, -1.0, 1.0) * near).xyz;\n    ray = (invprojview * vec4(vec2(x,y) * (far - near), far + near, far - near)).xyz;\n}"}},t={};function r(_){var a=t[_];if(void 0!==a)return a.exports;var e=t[_]={id:_,exports:{}};return n[_](e,e.exports,r),e.exports}r.n=n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return r.d(t,{a:t}),t},r.d=(n,t)=>{for(var _ in t)r.o(t,_)&&!r.o(n,_)&&Object.defineProperty(n,_,{enumerable:!0,get:t[_]})},r.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),r(84),r(548)})();